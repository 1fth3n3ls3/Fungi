<!DOCTYPE html><html><head><title></title></head><script type="module">
import App, { AppBuilder, gl, Shader, Material, Components, Entity } from "./fungi/engine/App.js";
import Vao, { Buf }	from "./fungi/core/Vao2.js";
import Maths, { Quat, Vec3 }		from "./fungi/maths/Maths.js";

import Gltf			from "./fungi.misc/GLTF.js";
import XhrPromise	from "./fungi.misc/XhrPromise.js";

import Armature			from "./fungi.armature/Armature.js";
import ArmaturePreview	from "./fungi.armature/ArmaturePreview.js";


//#############################################################################
(function(){new AppBuilder()
	.launch()
	.load_armature()
	.download( dl=>dl.addGrp( "shader", 
		"./fungi/shaders/VecWColor.txt", 
		"./fungi/shaders/LowPolyPhong.txt", 
		"./fungi.armature/shaders/ArmaturePreview.txt", 
		"./fungi.armature/shaders/ArmatureSkinPhong.txt", 
	) ) 
	.load_scene( true, true, false )
	.set_camera( 0, 10, 4, 0, 0.7, 0 )
	.add( dl_files )
	//.add_task( init )
	.render_loop( onDraw )
	//.render_on_mouse( onDraw )
	.build().catch( (e)=>console.error("error",e) );
})();

window.addEventListener( "keydown", function(e){	
	switch( e.keyCode ){
		case 37: gTime -= 0.01; break; //Left
		case 39: gTime += 0.01; break; //Right
		case 38: gPause = !gPause; break; //up
		case 40: gBall.Node.local.pos.x = 2.0; gBall.Node.isModified = true; break; //Down
	}
});

function q_dot_fix( buf ){
	let qa = new Quat();
	let qb = new Quat();
	let dot;

	for( let i=0; i < buf.length-4; i+=4 ){
		qa.from_buf( buf, i );
		qb.from_buf( buf, i+4 );
		dot = Quat.dot( qa, qb );

		//console.log( i/4, qa, qb, Quat.dot( qa, qb ) );

		if( dot < -0.98 ){
			//console.log( "Dot Fix", dot );
			qb.negate().to_buf( buf, i+4 );
		}
	}
}

async function dl_files(){
	//let dl	= await XhrPromise.get( "./RiggedSimple.gltf", "json", "./RiggedSimple0.bin", "arraybuffer" );
	let dl	= await XhrPromise.get( 
		//"./walk_anim.gltf", "json", "./walk_anim.bin", "arraybuffer",
		"./run_anim.gltf", "json", "./run_anim.bin", "arraybuffer",
		"./files/models/vegeta.txt", "text", "./files/models/vegeta.bin", "arraybuffer", //files/models/
	);
	
	//build_anim_bones( dl[0], dl[1] );
	build_target( dl[2], dl[3] );
	//LeftArm ,LeftForeArm
	//
	//console.log( gModel.Armature );
	//console.log( gTarget.Armature );
/*
	gRetarget = new Retarget( gModel, gTarget );
	gRetarget
		.add( "Hips", "Hips" )

		.add( "LeftUpLeg", "LeftUpLeg" )
		.add( "LeftLeg", "LeftLeg" )
		.add( "RightUpLeg", "RightUpLeg" )
		.add( "RightLeg", "RightLeg" )

		.add( "Spine", "Spine" )
		.add( "Spine1", "Spine1" )
		.add( "Spine2", "Spine2" )
		.add( "Neck", "Neck" )
		.add( "Head", "Head" )
		.add( "LeftArm", "LeftArm" )
		.add( "LeftForeArm", "LeftForeArm" )
		.add( "RightArm", "RightArm" )
		.add( "RightForeArm", "RightForeArm" )
		;
*/
	//console.log( gRetarget.items );
	//gAnim.at( 1.0  , gModel );
	//gRetarget.run();

	/*
	let props = Gltf.getMesh( "Cylinder", dl[0], dl[1], false ); //GLTF Sample's data is interleaved, Can not test bin to vao.
	let p	= props[0];
	let vao = Vao.standard_by_data( "Mesh", p.vertices.data, 3, p.indices.data, null, null, p.joints.data, p.weights.data, p.joints.compLen );
	e.Draw.add( vao, "ArmatureSkinPhong" );
	*/
	
	return true;
}

function build_anim_bones( json, bin ){
	let e		= App.$Draw( "Mesh" );
	let bones 	= Gltf.getSkin( "Armature", json, bin );
	gModel = e;
	//gModel.Node.setPos( 2, 0, 0 );

	//~~~~~~~~~~~~~~~~~~~~~~~~~
	Armature.$( e );
	gltf_armature( e, bones ); //Gltf.$armature( e, bones ); // Will Execute Armature.$() on e, then parse in bones.
	ArmaturePreview.$( e, "ArmaturePreview", 2 );

	//~~~~~~~~~~~~~~~~~~~~~~~~~
	let anim = Gltf.getSkinAnimation( "Armature|mixamo.com|Layer0", json, bin ); //Armature|mixamo.com|Layer0  Animation1
	q_dot_fix( anim["62"].rot.data );
	q_dot_fix( anim["67"].rot.data );
	//q_dot_fix( anim["57"].rot.data );

	console.log( e.Bones );

	gAnim = new AnimationBones( anim );
	//LeftLeg: 58
	//LeftUpLeg: 57
	//RightLeg: 63
	//RightUpLeg: 62
}


function build_target( json, bin ){
	let e = MeshLoader.entity( json, bin );
	//e.Node.setPos( 1, 0, 0 );

	gTarget = e;
}

//#############################################################################
let gModel, gAnim, gPause = false, gTarget, gRetarget;
let gTime = 0;

function onDraw( dt, ss ){
	//if(!gPause) gAnim.at( gTime , gModel );
	//gAnim.at( ss  , gModel );
	//gRetarget.run();

	App.ecs.sys_run();
}


//#############################################################################
function init(){
	return true;
}

function gltf_armature( e, bones, def_len=0.3 ){
	let arm = e.Armature;	

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Create Bones
	let i, b, ab, bLen = bones.length;
	for( i=0; i < bLen; i++ ){
		b	= bones[i];
		ab	= Armature.addBone( arm, b.name, 1, null, b.idx );

		if( b.rot ) ab.Node.setRot( b.rot );
		if( b.pos ) ab.Node.setPos( b.pos );
		if( b.scl ) ab.Node.setScl( b.scl );
	}

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Setting up Parent-Child
	for( i=0; i < bLen; i++ ){
		b	= bones[ i ];
		ab	= arm.bones[ b.idx ];

		// Can not have levels updated automaticly, Callstack limits get hit
		// Instead, using the Level from bones to manually set it.
		if( b.p_idx != null ) App.node.addChild( arm.bones[ b.p_idx ], ab, false );

		// Manual set node level, Must do it after addChild, else it will get overwritten.
		ab.Node.level = b.lvl; 
	}
	Armature.finalize( e );	//This updates World Transforms

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// With the WorldTransforms update, Calculate the Length of each bone.
	for( i=0; i < bLen; i++ ){
		ab	= arm.bones[ i ];
		if( ab.Node.children.length == 0 ){
			ab.Bone.length = def_len;
			continue;
		}

		b = ab.Node.children[0].Node.world;					// First Child's World Space Transform
		ab.Bone.length = ab.Node.world.pos.length( b.pos );	// Distance from Parent to Child
	}
}


/*
	1. Need to Convert Armature to T-Pose
	2. Calc T-Pose Offsets
	3. Animate

	class AnimArmature{
		constructor(){
		}
	}

	class HumanRig{
		static $( e ){
			if( e instanceof Entity && !e.HumanRig ) Entity.com_fromName( e, "HumanRig" );
		}

		constructor(){
			this.arm 	= null;
			this.hip	= null;
			this.chain	= {};

			this.arm_l	= null;
			this.arm_r	= null;
			this.leg_l	= null;
			this.leg_r	= null;
			this.spine	= null;
			this.head 	= null;
		}

		set_chain( ch_name, b_name_ary ){
			let b, ary = [];

			for( let bn of b_name_ary ){
				b = this.arm.get_bone_by_name( bn );

				ary.push({ 
					idx		: b.order,
					bind	: b.bind.clone(),
					tbind	: b.bind.cline(),
				});
			}

			this.chain[ ch_name ] = ary;
		}

		make_tpose(){
			return this;
		}
	}

	{	hip		: "",
		arm_l	: [ "","" ],
		arm_r	: [ "","" ],
		leg_r	: [ "","" ],
		leg_l	: [ "","" ],
		spine	: [ "","","","" ],
		head 	: [ "","" ],
	}

*/

// Only need to Animate Rotation mostly. Hip needs to handle Position BUT only Y most of the time.
class AnimationBones{
	constructor( a ){
		this.max_time 	= 0;
		this.time 		= null;
		this.time_i		= []; // Pre Calc the time between Frames, then invert it. 1 / (b-a)
		this.bones		= [];

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Save keyframes grouped as Bones, ties back to bone index.
		for( let i in a ){
			let b = a[ i ];

			if( !b.rot && !b.pos ) continue;

			if( !this.time && b.rot.time ) this.time = b.rot.time;

			//if( b.bone_idx == 58 || b.bone_idx == 57 ){

			this.bones.push({
				idx: b.bone_idx,
				rot: b.rot.data,
			});

			//}
		}

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Cache the scaler to calculate T between frames.
		for( let i=0; i < this.time.length-1; i++ ){
			this.time_i.push( 1 / ( this.time[ i+1 ] - this.time[i] ) ); //  1 / (b - a)
		}

		this.max_time = this.time[ this.time.length-1 ];

		//console.log( this.time );
		//console.log( this.max_time );

	}

	at( t, e ){
		let aBones	= e.Armature.bones,
			q		= new Quat(),
			fA		= 0, 
			fB, fT, i, b;

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Figure out which frame we're in.
		t = t % this.max_time;	// Passing in DeltaTime, this makes sure we stay within the limit of the animation
		for( i=this.time.length-2; i > 0; i-- )
			if( this.time[ i ] < t ){ fA = i; break; }

		fB = fA + 1;
		//fT = ( t - this.time[ fA ] ) * this.time_i[ fA ];
		fT = ( t - this.time[ fA ] ) / ( this.time[ fB ] - this.time[ fA ]);

		// NOTE, Issue between Frame 4 to 5.
		// Looks like the Axis is Inverted/


		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		for( b of this.bones ){
			q_buf_lerp( b.rot, fA * 4, fB * 4, fT, q );
			//q_buf_slerp( b.rot, fA * 4, fB * 4, fT, q );

			if( b.idx == 57 ){
				//App.debug.reset().quat( q );
				//console.log( fA, fB, fT, t, this.time[ fA ], this.time[ fB ] , q.getAxisAngle() );
				//q_buf_debug( b.rot, fA * 4, fB * 4 );
			}
			
			aBones[ b.idx ].Node.setRot( q );
		}

		e.Armature.isModified = true;	 
	}
}

function q_buf_lerp( ary, ai, bi, t, out ){
	let ti = 1 - t;
	out[ 0 ] = ary[ ai ] * ti + ary[ bi ] * t;
	out[ 1 ] = ary[ ai + 1 ] * ti + ary[ bi + 1 ] * t;
	out[ 2 ] = ary[ ai + 2 ] * ti + ary[ bi + 2 ] * t;
	out[ 3 ] = ary[ ai + 3 ] * ti + ary[ bi + 3 ] * t;
	return out.norm();
}

function q_buf_slerp( ary, ai, bi, t, out ){
	let ti = 1 - t;
	let qA = new Quat( ary[ ai ], ary[ ai + 1 ], ary[ ai + 2 ], ary[ ai + 3 ] );
	let qB = new Quat( ary[ bi ], ary[ bi + 1 ], ary[ bi + 2 ], ary[ bi + 3 ] );

	Quat.slerp( qA, qB, t, out )

	return out.norm();
}

function q_buf_debug( ary, ai, bi ){
	let qA = new Quat( ary[ ai ], ary[ ai + 1 ], ary[ ai + 2 ], ary[ ai + 3 ] );
	let qB = new Quat( ary[ bi ], ary[ bi + 1 ], ary[ bi + 2 ], ary[ bi + 3 ] );

	console.log( qA, qB, Quat.dot( qA, qB ) );
}


//#############################################################################
class MeshLoader{
	static entity( txt, bin ){
		let e = App.$Draw( "Target" );
		//
		//
		let spec = this.parse_section( "Vao", txt );
		let s = spec["Vegeta"];
		console.log( s );

		let vao = Vao.standard_by_bin( "Test", s, bin );
		e.Draw.add( vao, "ArmatureSkinPhong" );

		/*
		let dv 	= ( bin instanceof ArrayBuffer )? new DataView( bin ) : bin;
		let vao	= new Vao( "Vegeta" ).bind();
		vao.add_vertices( Buf.new_array_bin( dv, s.vertices.byteStart, s.vertices.byteLen, true, false ), s.vertices.compLen );
		vao.add_indices( Buf.new_element_bin( dv, s.indices.byteStart, s.indices.byteLen, true, false ) );
		vao.elmCount = s.indices.elmCount;
		vao.unbind_all();
		*/



		this.load_bones( e, txt );

		ArmaturePreview.$( e, "ArmaturePreview", 2 );

		return e;


		//let vao = Vao.standard_by_data( "Mesh", p.vertices.data, 3, p.indices.data, null, null, p.joints.data, p.weights.data, p.joints.compLen );


		/*
		d_vao	= (( i.draw_opt & DOPT_VAO ) != 0);
		d_arm	= (( i.draw_opt & DOPT_ARM ) != 0);
		d_prev	= (( i.draw_opt & DOPT_PREV ) != 0);
		if( !d_vao && !d_arm && !d_prev ) continue;

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		e = App.$Draw( i.name );

		if( d_vao ) this.build_vao( e, i );

		if( d_arm || d_prev ){
			load_bones( Armature.$( e ), i );

			if( !d_arm ) e.Armature.isActive = false; // Disable Arm Rendering
			if( d_prev ) ArmaturePreview.$( e, "ArmaturePreview", 2 );
		}
		*/
	}

	static parse_section( sec, txt ){
		let aPos = txt.indexOf( "<" + sec + ">" ) + sec.length + 2;
		let bPos = txt.indexOf( "</" + sec + ">" );

		if( aPos == -1 || bPos == -1 || bPos <= aPos ) return null;

		let tmp	= txt.substring( aPos, bPos );

		try{ return JSON.parse( tmp ); }
		catch(err){ console.error( err.message, "\n" , tmp ); }

		return null;
	}


	static load_bones( e, txt ){
		let json = this.parse_section( "Armature", txt );
		Armature.$( e );

		let i, b, ab, bLen = json.length, arm = e.Armature;

		for( i=0; i < bLen; i++ ){
			b	= json[i];
			//ab 	= Armature.addBone( arm, b.name, b.len, null, b.idx );
			ab 	= arm.add_bone( b.name, b.len, null, b.idx );

			// Can not have levels updated automaticly, Callstack limits get hit
			// Instead, using the Level from bones to manually set it.
			//if( b.p_idx != null ) App.node.addChild( arm.bones[ b.p_idx ], ab, false );
			if( b.p_idx != null ) arm.bones[ b.p_idx ].Node.add_child( ab, false );

			// Manual set node level, Must do it after addChild, else it will get overwritten.
			ab.Node.level = b.lvl; 

			if( b.rot ) ab.Node.setRot( b.rot );
			if( b.pos ) ab.Node.setPos( b.pos );
			if( b.scl ) ab.Node.setScl( b.scl );
		}
		Armature.finalize( e );	//This updates World Transform
	}
}

class Retarget{
	constructor( eFrom, eTo ){
		this.items 		= [];
		this.from 		= eFrom.Armature;
		this.to 		= eTo.Armature;

		this.from_ws	= [];
		this.to_ws		= [];

		let i=0;
		for( let b of eFrom.Armature.bones ){
			//this.from_ws[ i++ ] = b.Node.world.rot.clone();
			this.from_ws[ i++ ] = (b.Node.parent)? b.Node.parent.Node.world.rot.clone() : new Quat();
		}

		i=0;
		for( let b of eTo.Armature.bones ){
			//this.to_ws[ i++ ] = b.Node.world.rot.clone();
			this.to_ws[ i++ ] = (b.Node.parent)? b.Node.parent.Node.world.rot.clone() : new Quat();
		}
	}

	add( aName, bName ){
		this.items.push({
			from: this.from.get_bone( aName ).Bone.order,
			to: this.to.get_bone( bName ).Bone.order,
		});
		return this;
	}

	run(){
		let aa, bb;
		for( let i of this.items ){
			// Bone Reference
			aa = this.from.bones[ i.from ];	// Src Animated Bone of Skeleton A
			bb = this.to.bones[ i.to ];		// Target Bone of Skeleton B

			let dif = new Quat(); //.setAxisAngle( [1,0,0], Maths.toRad(45) );

			//Get the Difference between the Src Bind Rot and Animated Rot
			dif.from_mul( Quat.invert( aa.Bone.bind.rot ), aa.Node.local.rot );

			// Get Model Space of the Bone's PARENT.. VERY VERY IMPORTANT
			// Need to convert from One Model Space to Another. The Local space
			// of a bone is the PARENT BONE's Model Space Transform
			let wpa = this.from_ws[ i.from ];
			let wpb = this.to_ws[ i.to ];

			// Get the Parent Bone Difference, Convert from the Src
			// Model View Space to the target's model view space.
			let a2b = Quat.mul( Quat.invert( wpa ), wpb );

			dif.pmul( wpa )	// Convert Local Space Difference, to Src Model Space
				.mul( a2b )	// Move it from Src Modal Space to Target Model Space of targeted bone
				.pmul( Quat.invert(wpb) )	// Convert it to Target's bone Local Space
				.mul( bb.Bone.bind.rot );	// Apply Change to Target's Bind Rot

			// NOTE: Target isn't in a good TPose, Need to create a TPose for it and try
			// to add an extra step to handle a custom TPose. The Src is in a perfect tpose
			// already, but should figure out how to handle custom tpose from both sides.
			
			bb.Node.setRot( dif );			// Apply Change to Target
		}
		this.to.isModified = true;
	}

	//			//aa.Node.local.rot.from_mul( aa.Bone.bind.rot, q ); // Apply Change to Source

	run_OLD(){
		let q = new Quat();
		let qi = new Quat();
		let cnt = -1;
		let aa, bb;
		for( let i of this.items ){
			cnt++;
			aa = this.from.bones[ i.from ];
			bb = this.to.bones[ i.to ];

			/*
			Bind Pos in World Space
			Need Bone Transform Bridges
			When animation is set, recaculate WorldSpace for Animation.
			*/

			/**/
			//let wa = aa.Node.get_world_transform( null, true );
			//let wb = bb.Node.get_world_transform( null, true );

			let wa = this.from_ws[ i.from ];
			let wb = this.to_ws[ i.to ];

			//let a2b = Quat.mul( Quat.invert( wa.rot ), wb.rot );
			//let b2a = Quat.mul( Quat.invert( wb.rot ), wa.rot );

			let a2b = Quat.mul( Quat.invert( wa ), wb );
			let b2a = Quat.mul( Quat.invert( wb ), wa );

			aa.Node.local.rot.rx( Maths.toRad(-45) );
			//aa.Node.local.rot.ry( Maths.toRad(-90) );

			let waa = aa.Node.get_world_transform( null, true );

			//let dif = Quat.mul(
			//	Quat.invert( wa.rot ),
			//	waa.rot
			//);

			//let dif = Quat.mul(
			//	Quat.invert( wa ),
			//	waa.rot
			//);

			//let wap = aa.Node.get_world_rot( null, false );
			let dif = Quat.mul(
				Quat.invert( aa.Bone.bind.rot ),
				aa.Node.local.rot,
			);

			//bb.Node.local.rot.from_mul(
			//	dif, a2b, 
			//).pmul( b2a );


			//let wbp = bb.Node.get_world_rot( null, false );
			//bb.Node.local.rot.from_mul(
			//	dif, a2b, 
			//).pmul( b2a );//.pmul( bb.Bone.bind.rot );

			//a2b = Quat.mul( Quat.invert( aa.Bone.bind.rot ), bb.Bone.bind.rot );
			//b2a = Quat.mul( Quat.invert( bb.Bone.bind.rot ), aa.Bone.bind.rot );

			//q.from_mul( dif, a2b, )
			//.pmul(b2a);

			//.pmul( a2b );

			//bb.Node.setRot( q );

			//console.log( q, bb.Bone.bind.rot );

			//if( i.from == 57 ) bb.Node.local.rot;

			bb.Node.isModified = true;
		}

		this.to.isModified = true;
	}
}


// https://community.khronos.org/t/skeleton-animation-retargeting-orientation-only-same-skeleton/75872
// https://gamedev.stackexchange.com/questions/27058/how-to-programatically-retarget-animations-from-one-skeleton-to-another
// view-source:https://threejs.org/examples/webgl_loader_sea3d_bvh_retarget.html
// https://threejs.org/examples/jsm/utils/SkeletonUtils.js
</script><body>
</body></html>