<!DOCTYPE html><html><head><title></title></head><script type="module">
import App	from "../fungi/engine/App.js";
import Maths, { Vec3, Quat }	from "../fungi/maths/Maths.js";
import Spring					from "../fungi/maths/Spring.js";
import Vec3Spring				from "../fungi/data/Vec3Spring.js";
import Transform				from "../fungi/maths/Transform.js";

import Motion					from "../fungi.test/Motion.js";
//import FacedCube				from "../fungi/primitives/FacedCube.js";

import Armature					from "../fungi.armature/Armature.js";
import ArmaturePreview			from "../fungi.armature/ArmaturePreview.js";

import Pose						from "./Pose.js";
import { Chain }				from "./HumanRig.js";


//import Jiggly, { JigglySystem }	from "../fungi.armature/Jiggly.js";

import _NA						from "../fungi.misc/MeshLoader.js";
import FungiGLTF		from "../fungi.misc/FungiGLTF.js";
import XhrPromise		from "../fungi.misc/XhrPromise.js";

//#############################################################################
App.builder()
	.launch()
	.load_armature()
	.download( dl=>dl.addGrp( "shader", 
		"../fungi/shaders/VecWColor.txt", 
		"../fungi.armature/shaders/ArmatureSkinPhong.txt",
		"../fungi.armature/shaders/ArmaturePreview.txt" )
	)
	.load_scene( true, true, true )
	.add( init )
	.render_loop( onDraw )
	.set_camera( -40, 25, 4.0, 0, 1, 0 )
	.build().catch( e=>console.error("error",e) );


//#############################################################################
window.addEventListener("keyup", function(e){
	switch( e.keyCode ){
		case 32: gRun	= !gRun; break;		// Space
		case 66: gPause	= !gPause; break;	// b

		// 1 to 6
		case 49: gMover = gM_Sin; break;
		case 50: gMover = gM_Circle; break;
		case 51: gMover = gM_RndRadius; break;
		case 52: gMover = gM_Axis; break;
		case 53: gMover = gM_NoiseP; break;
		case 54: gMover = gM_NoiseR; break;
	}
});


//#############################################################################
let gCube, gMover, gSpring, gArm, gRun = false, gPause = false;
let gM_Sin, gM_Circle, gM_RndRadius, gM_Axis, gM_NoiseP, gM_NoiseR;
let isDebug = false;

let gPose, gBind;

function onDraw(dt, ss){
	/**/
	if(!gPause){
		if( gRun ){
			gArm.Armature.isModified = true;
			gMover( dt );
			gPose.root_offset.copy( gArm.Node.local );
			gPose.update_world();
			gSpring.update( gBind, gPose, dt );
		}		
		//if( gSpring )	gSpring( dt );
		//console.log( "x" );
	}

	App.ecs.sys_run();
}

function initx(){
	let e = App.ecs.entity_find( "Mesh01" );

	//........................
	gM_Sin			= Motion.sin( e, 1.0, [2,0,0] );
	gM_Circle		= Motion.circle( e, 1.0, 1 );
	gM_RndRadius	= Motion.rnd_radius( e, 0.1, 2 );
	gM_Axis			= Motion.axis_sin_rot( e, 2, Vec3.FORWARD, 45 );
	gM_NoiseP		= Motion.noise_pos( e, 3, [-2,0,-2], [2,0,2], 0.3 );
	gM_NoiseR		= Motion.noise_rot( e, 5, [-45, -45, -45], [45, 45, 45], 0.25 );
	gMover			= gM_Sin;

	//........................
	gArm 	= e;
	gSpring	= SpringChain( 0.7, 0.3 / e.Armature.bones.length, 0.6, 2.8 / e.Armature.bones.length );
	

	//........................
	return true;
}

async function init(){
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	let dl_ary = ["../robo_trex.gltf", "json", "../robo_trex.bin", "arraybuffer" ];
	let dl = await XhrPromise.get.apply( XhrPromise, dl_ary );

	//let e = FungiGLTF.$debug( "TargetA", dl[0], dl[1], "Armature" );
	let e = FungiGLTF.$preview( "TargetB", "Armature", dl[0] );
	gArm = e;

	gPose = new Pose( e.Armature );
	gBind = new Pose( e.Armature );
	gBind.update_world();

	let chain = new Chain();
	chain.set_bones( gBind, ["tail_1","tail_2","tail_3","tail_4","tail_5","tail_6","tail_7"] );

	gSpring = new BoneChainSpring( chain );
	gSpring
		.set_pos( gBind )
		.use_euler( 0.6, 0.5 / 7, 0.6, 2.2 / 7 );

	//console.log( e.Armature.bones );

	//........................
	gM_Sin			= Motion.sin( e, 1.0, [2,0,0] );
	gM_Circle		= Motion.circle( e, 1.0, 1 );
	gM_RndRadius	= Motion.rnd_radius( e, 0.1, 2 );
	gM_Axis			= Motion.axis_sin_rot( e, 2, Vec3.FORWARD, 45 );
	gM_NoiseP		= Motion.noise_pos( e, 3, [-2,0,-2], [2,0,2], 0.3 );
	gM_NoiseR		= Motion.noise_rot( e, 5, [-45, -45, -45], [45, 45, 45], 0.25 );
	gMover			= gM_Sin;

	//........................
	

	//........................
	return true;
}

//#############################################################################

function SpringChain( damp_v=0.1, damp_inc=0.2, osc_v = 0.6, osc_inc=0.9 ){
	let arm			= gArm.Armature;
	let bary 		= arm.bones;
	let chain_len	= bary.length;
	let chain		= new Array( chain_len );

	let bone_tail	= new Vec3( 0, 0, 0 );
	let tpos 		= new Vec3();
	let wp			= new Transform();
	let wc			= new Transform();
	let rot_inv		= new Quat();
	let rot 		= new Quat();

	let ray_a		= new Vec3();
	let ray_b		= new Vec3();

	let itm;

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	bary[0].Node.get_world_transform( wp, false );
	for( let i=0; i < chain_len; i++ ){
		bone_tail.set( 0, bary[i].Bone.length, 0 );

		wp	.add( bary[i].Bone.bind )
			.transform_vec( bone_tail, tpos );

		chain[i] = {
			follow_vel	: new Vec3(),
			follow_pos	: tpos.clone(),
			damp_ratio	: damp_v,
			osc_ps		: Maths.PI_2 * osc_v,
		};

		damp_v	+= damp_inc;
		osc_v	+= osc_inc;
	}

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	return ( dt ) => {
		bary[0].Node.get_world_transform( wp, false );
		if( isDebug ) App.debug.reset();

		for(let i=0; i < chain_len; i++ ){
			itm = chain[i];

			//bary[i].Node.get_world_transform( wp, false );

			wp.rot.invert( rot_inv );
			wc.from_add( wp, bary[i].Bone.bind );
			
			//App.debug.point( wp.pos, 0 );
			bone_tail.set( 0, bary[i].Bone.length, 0 )
			wc.transform_vec( bone_tail, tpos );

			if( isDebug ) App.debug.point( tpos, 6 );

			if( isDebug ) App.debug.point( itm.follow_pos, (i==10)?8:1 );

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			Spring.semi_implicit_euler_vec3( dt, itm.osc_ps, itm.damp_ratio, tpos, itm.follow_pos, itm.follow_vel );

			if( isDebug ) App.debug.point( itm.follow_pos, (i==10)?0:2 );

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			ray_a.from_sub( tpos, wc.pos ).norm();
			ray_b.from_sub( itm.follow_pos, wc.pos ).norm();

			rot .from_unit_vecs( ray_a, ray_b )
				.mul( wc.rot )
				.pmul( rot_inv );

			wp.add( rot, bary[i].Bone.bind.pos, bary[i].Bone.bind.scl ); // Next WS Parent

			bary[i].Node.setRot( rot );
		}

		arm.isModified = true;
	};
}

class BoneChainSpring{
	constructor( chain ){
		this.nodes = new Array( chain.cnt );

		let i;
		for( i=0; i < chain.cnt; i++ ){
			this.nodes[ i ] = {
				idx		: chain.bones[ i ],
				spring	: new Vec3Spring(),
			};
		}
	}

	use_euler( damp=0.5, damp_inc=0.1, osc=1, osc_inc=0.2 ){
		let i;
		for( i=0; i < this.nodes.length; i++ ){
			this.nodes[ i ].spring.use_euler(  osc + osc_inc*i, damp + damp_inc * i );
		}
		return this;
	}

	set_pos( pose ){
		let i, b, pos = new Vec3();
		for( i of this.nodes ){
			b = pose.bones[ i.idx ];
			pos.set( 0, b.len, 0 );

			b.world.transform_vec( pos );
			i.spring.set_pos( pos );  // save trail position.

			//App.debug.point( pos,1 );
		}
		return this;
	}

	update( bind, pose, dt ){
		let pt = new Transform(),
			ct = new Transform(),
			tail_pos = new Vec3(),
			ray_a = new Vec3(),
			ray_b = new Vec3(),
			rot = new Quat(),
			bone, i, s_pos;

		bone = pose.bones[ this.nodes[0].idx ];

		pt.copy( pose.bones[ bone.p_idx ].world );

		App.debug.reset();
		for( i of this.nodes ){
			bone = bind.bones[ i.idx ];

			//console.log( pt, bone.local  );

			ct.from_add( pt, bone.local ); 
			
			tail_pos.set( 0, bone.len, 0 );	
			ct.transform_vec( tail_pos );

			s_pos = i.spring.set_target( tail_pos ).update( dt );
			
			//if( i.idx == this.nodes[0].idx ){
			//App.debug.point( s_pos );
			//App.debug.point( tail_pos, 1 );
			//}

			ray_a.from_sub( tail_pos, ct.pos ).norm();
			ray_b.from_sub( s_pos, ct.pos ).norm();

			rot .from_unit_vecs( ray_a, ray_b )
				.mul( ct.rot )
				.pmul_invert( pt.rot );

			pose.set_bone( bone.idx, rot );
			pt.add( rot, bone.local.pos, bone.local.scl );
		}

		pose.apply();
	}
}


/*

	get_pose_bone_tail( idx, tf ){
		let bind = this.bind_pose.bones[ idx ],
			pose = this.pose_a.bones[ idx ];

		tf	.copy( pose.world )
			.add( bind.local.rot, [0, bind.len,0], bind.local.scl );
			
		return tf;	
	}
*/
</script><body></body></html>