<!DOCTYPE html><html><head><title></title></head><script type="module">
import App, { AppBuilder }		from "../fungi/engine/App.js";
import Maths, { Quat, Vec3 }	from "../fungi/maths/Maths.js";
import XhrPromise				from "../fungi.misc/XhrPromise.js";
import FungiGLTF, {Gltf} 		from "../fungi.misc/FungiGLTF.js";
import GltfExport 				from "../fungi.misc/GltfExport.js";
import Animation				from "../fungi.animation/Animation.js";
import HumanRig 				from "./HumanRig.js";

//#############################################################################
(function(){new AppBuilder()
	.launch()
	.load_armature()
	.download( dl=>dl.addGrp( "shader", 
		"../fungi/shaders/VecWColor.txt", 
		//"./fungi/shaders/LowPolyPhong.txt", 
		"../fungi.armature/shaders/ArmaturePreview.txt", 
		"../fungi.armature/shaders/ArmatureSkinPhong.txt", 
	) ) 
	.load_scene( true, true, true )
	.set_camera( -50, 10, 3, 0, 0.7, 0 )
	.add( dl_files )
	.render_loop( onDraw )
	//.render_on_mouse( onDraw )
	.build().catch( (e)=>console.error("error",e) );
})();

let gIsActive = true;
let gRigTar, gRigSrc, gSession, gAnimation;


async function dl_files(){
	let dl	= await XhrPromise.get( 
		"../walking.gltf", "json", "../walking.bin", "arraybuffer",
		"../files/models/mannequin_female.gltf", "json", "../files/models/mannequin_female.bin", "arraybuffer", //files/models/
	);
	
	build_src( dl[0], dl[1] );
	build_target( dl[2], dl[3] );

	gSession = new RetargetSession()
		.set_rigs( gRigSrc, gRigTar )
		.set_src_animation( gAnimation )
		.build();

	return true;
}


function build_src( json, bin ){
	let e 		= FungiGLTF.$preview( "src_preview", "Armature", json );
	
	gRigSrc		= new HumanRig( e, true );
	gAnimation	= FungiGLTF.animation( "Armature|mixamo.com|Layer0", json, bin );
}


function build_target( json, bin ){
	//let e = FungiGLTF.$preview( "src_preview", "Armature", json );
	//let e = FungiGLTF.$skin( "src_preview", json, bin );
	let e = FungiGLTF.$debug( "src_preview", json, bin );

	gRigTar = new HumanRig( e );
	/*	.set_leg_l( ["LeftUpLeg", "LeftLeg"] )
		.set_leg_r( ["RightUpLeg", "RightLeg"] )
		.set_arm_l( ["LeftArm", "LeftForeArm"] )
		.set_arm_r( ["RightArm", "RightForeArm"] )
		.set_foot( 0, "LeftFoot" )
		.set_foot( 1, "RightFoot" )
		.gen_tpose();
	*/

	e.Node.setPos( 1, 0, 0 );
}


//#############################################################################
function onDraw( dt, ss ){
	/**/
	if( gIsActive ){
		//gSession.play_realtime( dt );
		gSession.play_both( dt );
		//gSession.play_target( dt );
	}

	App.ecs.sys_run();
}


//############################################################################
class Animator{
	constructor(){
		this.clock = 0;
	}

	/////////////////////////////////////////////////////////////////
	// 
	/////////////////////////////////////////////////////////////////
		tick( dt ){ this.clock += dt; return this; }
		reset( ){ this.clock = 0; return this; }

		key_frame( ti, anim, pose ){
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			if( ti >= anim.frame_cnt ){ console.log("key frame index exceeds total key frames."); return this; }

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			let q		= new Quat(),
				v		= new Vec3(),
				qi 		= ti*4,
				vi 		= ti*3,
				track;

			for( track of anim.tracks ){
				if( ti >= anim.times[ track.time_idx ].length ) continue;

				switch( track.type ){
					case "rot": 
						Animation.quat_buf_copy( track.data, q, qi );
						pose.set_bone( track.joint_idx, q ); 
						break;
					case "pos": 
						Animation.vec3_buf_copy( track.data, v, vi );
						pose.set_bone( track.joint_idx, null, v );
						break;
				}
			}
		}

		// Run animation and save results to pose object
		update( anim, pose ){
			let f_times	= this._frame_times( anim ),
				q 		= new Quat(),
				v		= [0,0,0],
				track, frame;

			for( track of anim.tracks ){
				if( track.interp == "STEP" ) continue; //TODO, add support for this

				frame = f_times[ track.time_idx ]; // [ FA_IDX, FB_IDX, NORM_TIME ]

				switch( track.type ){
					case "rot":
						Animation.quat_buf_blend( track.data, frame[0]*4, frame[1]*4, frame[2], q );
						pose.set_bone( track.joint_idx, q ); 
						break;
					case "pos":
						Animation.vec3_buf_lerp( track.data, frame[0]*3, frame[1]*3, frame[2], v );
						pose.set_bone( track.joint_idx, null, v );
						break;
				}
			}

			return this;
		}

		// Every animation can have multiple shared time tracks.
		// So we incrmement our animation clock, then for each time
		// track we find between which two frames does the time exist.
		// Then we normalized the time between the two frames.
		// Return: [ [ FA_IDX, FB_IDX, NORM_TIME ], ... ];
		_frame_times( anim ){
			// Find the Frames for each group time.
			let j, i, time, fa, fb, ft,
				times	= anim.times,
				rtn		= new Array( anim.times.length ),
				clock 	= this.clock % anim.time_max;

			for( j=0; j < anim.times.length; j++ ){
				time = anim.times[ j ];

				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				// Find the first frame that is less then the clock.
				fa = 0;
				for( i=time.length-2; i > 0; i-- )
					if( time[i] < clock ){ fa = i; break; }

				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				// Normalize Time Between Frames
				fb = fa + 1;
				ft = ( clock - time[ fa ] ) / ( time[ fb ] - time[ fa ] );
				//ft = ( data.clock - time[ fa ] ) * frame_inc[ fa ];
				rtn[ j ] = [ fa, fb, ft ];
			}
			return rtn;
		}
}


//############################################################################
class RetargetSession{
	constructor(){
		this.rig_src	= null;
		this.rig_tar	= null;

		this.anim_src 	= null;
		this.anim_tar 	= null;

		this.animator 	= new Animator();
		this.bone_map 	= new Array();

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// retarget cached math objects
		this.convert	= new Quat();
		this.rot 		= new Quat();
		this.pos 		= new Vec3();
		this.scale 		= new Vec3();
		this.a			= new Vec3();
		this.b			= new Vec3();
	}

	/////////////////////////////////////////////////////////
	// setters / getters
	/////////////////////////////////////////////////////////
		set_rigs( src, tar ){
			this.rig_src = src;
			this.rig_tar = tar;
			this._auto_bone_map();
			return this;
		}

		set_src_animation( anim ){
			this.anim_src = anim;
			this._build_target_animation();
			return this;
		}

	/////////////////////////////////////////////////////////
	// Play Animations
	/////////////////////////////////////////////////////////
		
		// Play Final Retargeted Animation
		play_target( dt ){
			this.animator
				.tick( dt )
				.update( this.anim_tar, this.rig_tar.pose_a );
			this.rig_tar.apply_pose();
			return this;
		}

		// Play Source and Retarted Animation
		play_both( dt ){
			this.animator
				.tick( dt )
				.update( this.anim_src, this.rig_src.pose_a )
				.update( this.anim_tar, this.rig_tar.pose_a );
			this.rig_tar.apply_pose();
			this.rig_src.apply_pose();
			return this;
		}

		// Realtime Retargeting
		play_realtime( dt ){
			this.animator
				.tick( dt )
				.update( this.anim_src, this.rig_src.pose_a );

			this.rig_src.apply_pose();
			this.rig_src.update_world();	// Update World Space 

			// Run Retarget on Each Bone.
			let b;
			for( b of this.bone_map ){
				this.retarget_bone( b.src_name, b.tar_name, ( b.src_name == "Hips" ) );
			}

			this.rig_tar.apply_pose();
			return this;
		}

	/////////////////////////////////////////////////////////
	// configuration
	/////////////////////////////////////////////////////////
		// Simple auto mapping, just matches mixamo bone names
		_auto_bone_map(){
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Get a list of Bones from the Source Animation Rig
			let b, m, map = {};
			for( b of this.rig_src.bind_pose.bones ){
				map[ b.name ] = {
					src_idx		: b.idx,
					src_name	: b.name,
					tar_idx		: -1,
					tar_name	: "",
				};
			}

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Loop through Target Rig and find common name with the srr rig
			for( b of this.rig_tar.bind_pose.bones ){
				m = map[ b.name ];

				if( !m ){ console.log("Target bone has no source equivalent : ", b.name ); continue; }
				if( m.tar_idx != -1 ){ console.log("Target bone name is duplicated : ", b.name ); continue; }
				
				m.tar_idx	= b.idx;
				m.tar_name	= b.name;
			}

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Only save map data that has a successful link between
			// the two animation rigs

			this.bone_map.length = 0;
			for( b in map ){
				if( map[b].tar_idx == -1 ){ 
					//console.log("Source Bone has no target equivalent : ", b);
					continue;
				}

				this.bone_map.push( map[b] ) ;
				delete map[b];
			}
		}

		_find_bone_map( src_idx ){
			let b;
			for( b of this.bone_map ){
				if( b.src_idx == src_idx ) return b;
			}
			return null;
		}

		_build_target_animation(){
			let src_tracks	= this.anim_src.tracks,
				src_bind	= gRigSrc.bind_pose;
			
			this.anim_tar = new Animation();

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Set Time Arrays
			for( let ary of this.anim_src.times ){
				this.anim_tar.add_time_array( ary );
			}

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Recreate Tracks with Empty Sized Arrays
			let st, src_bone, b_map;
			for( st of src_tracks ){
				src_bone	= src_bind.bones[ st.joint_idx ];
				b_map		= this._find_bone_map( src_bone.idx );

				//console.log( st.type, st.time_idx, st.joint_idx, src_bone.idx, src_bone.name, b_map, st );

				this.anim_tar.add_joint_track(
					st.type, 
					st.time_idx, 
					b_map.tar_idx, 
					st.interp, 
					new Float32Array( st.data.length )
				);
			}
		}


	/////////////////////////////////////////////////////////
	// 
	/////////////////////////////////////////////////////////
		
		// Run Retargeting and save the result to the target animation object
		build(){
			let b, i, frame_cnt = this.anim_src.frame_cnt;

			for( i=0; i < frame_cnt; i++ ){
				this.animator.key_frame( i, this.anim_src, this.rig_src.pose_a ); // Generate Pose
				//this.rig_src.apply_pose();
				this.rig_src.update_world();	// Update World Space 

				// Run Retarget on Each Bone.
				for( b of this.bone_map ){
					this.retarget_bone( b.src_name, b.tar_name, ( b.src_name == "Hips" ) );
				}

				this._save_target_track( i );
			}

			return this;
		}

		_save_target_track( i ){
			let tk, b,
				ri = i * 4,
				pi = i * 3;

			for( tk of this.anim_tar.tracks ){
				b = this.rig_tar.pose_a.bones[ tk.joint_idx ];

				switch( tk.type ){
					case "pos":
						tk.data[ pi ]	= b.local.pos[ 0 ];
						tk.data[ pi+1 ]	= b.local.pos[ 1 ];
						tk.data[ pi+2 ]	= b.local.pos[ 2 ];
						break;
					case "rot":
						tk.data[ ri ]	= b.local.rot[ 0 ];
						tk.data[ ri+1 ]	= b.local.rot[ 1 ];
						tk.data[ ri+2 ]	= b.local.rot[ 2 ];
						tk.data[ ri+3 ]	= b.local.rot[ 3 ];
						break;
				}
			}
		}

		retarget_bone( from_name, to_name, inc_pos=false, y_only=true ){
			// Pseudo code to retarget Rotations
			//   shift = from_t.bone.ws.rot.invert * to_t.bone.ws.rot
			//   dif   = from_t.parent_bone.ws.rot * src_pose.bone.ls.rot
			//   dif   *= dot( dif, from_t.bone.ws.rot  ) >= 0 ? shift : -shift;
			//   final_pose.bone.ls.rot = to_t.parent_bone.ws.rot.invert * Dif

			// Pseudo code to retarget ip position
			//   scale 	 = to_t.ws.pos / from_t.ws.pos;
			//   pos_dif = ( src.ws.pos - from_t.ws.pos ) * scale;
			//   final 	 = to_t.ls.pos + pos_dif;

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Get the Main Bones Needed.
			let a_rig_bind = this.rig_src.bind_pose,
				b_rig_bind = this.rig_tar.bind_pose,
				a_rig_pose = this.rig_src.pose_a,
				b_rig_pose = this.rig_tar.pose_a,

				a_bind = a_rig_bind.get_bone( from_name ),
				a_pose = a_rig_pose.get_bone( from_name ),
				b_bind = b_rig_bind.get_bone( to_name ),
				b_pose = b_rig_pose.get_bone( to_name ),

				ap_bind_rot = ( a_bind.p_idx != null )?
					a_rig_bind.bones[ a_bind.p_idx ].world.rot :
					a_rig_bind.root_offset.rot,

				bp_bind_rot = ( b_bind.p_idx != null )?
					b_rig_bind.bones[ b_bind.p_idx ].world.rot :
					b_rig_bind.root_offset.rot;

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Create Bind Rotation Difference from FROM -> TO
			this.convert
				.from_invert( a_bind.world.rot )
				.mul( b_bind.world.rot );

			// Isolate bone by using parent's world bind rotation + animated local space rot
			this.rot.from_mul( ap_bind_rot, a_pose.local.rot );

			// Do Check of the Bone's SRC WS rotation based on Src WS Bind Rotation.
			if( Quat.dot( this.rot, a_bind.world.rot ) < 0 ) this.convert.negate();

			this.rot
				.mul( this.convert )			// Move rotation to target bones world space
				.pmul_invert( bp_bind_rot );	// Convert down to local space

			b_rig_pose.set_bone( b_pose.idx, this.rot );


			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			if( inc_pos ){
				// Get Scale   s = to / from
				this.a.copy( a_bind.world.pos ).near_zero();
				this.b.copy( b_bind.world.pos ).near_zero();
				this.scale.from_div( this.b, this.a );

				this.pos
					.from_sub( a_pose.world.pos, a_bind.world.pos )	// Get the Animation Difference from Bind Pose
					.mul( this.scale )								// Scale it to fit in TO
					.add( b_bind.world.pos );						// Add Scaled Difference to TO's Bind Position

				if( y_only ){
					this.pos[ 0 ] = b_bind.world.pos[ 0 ];
					this.pos[ 2 ] = b_bind.world.pos[ 2 ]; 
				}

				b_rig_pose.set_bone( b_pose.idx, null, this.pos );
			}

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			return this;
		}
}


</script><body>
</body></html>