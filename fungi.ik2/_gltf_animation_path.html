<!DOCTYPE html><html><head><title></title></head><script type="module">
import App, { AppBuilder, gl, Shader, Material, Components, Entity } from "../fungi/engine/App.js";
import Vao, { Buf }	from "../fungi/core/Vao2.js";
import Maths, { Quat, Vec3 }		from "../fungi/maths/Maths.js";
import Transform		from "../fungi/maths/Transform.js";

import Gltf			from "../fungi.misc/GLTF.js";
import XhrPromise	from "../fungi.misc/XhrPromise.js";

import Armature			from "../fungi.armature/Armature.js";
import ArmaturePreview	from "../fungi.armature/ArmaturePreview.js";


//#############################################################################
(function(){new AppBuilder()
	.launch()
	.load_armature()
	.download( dl=>dl.addGrp( "shader", 
		"../fungi/shaders/VecWColor.txt", 
		//"./fungi/shaders/LowPolyPhong.txt", 
		"../fungi.armature/shaders/ArmaturePreview.txt", 
		"../fungi.armature/shaders/ArmatureSkinPhong.txt", 
	) ) 
	.load_scene( true, true, false )
	.set_camera( -90, 0, 1, 0, 0.3, 0 )
	.add( dl_files )
	.render_loop( onDraw )
	//.render_on_mouse( onDraw )
	.build().catch( (e)=>console.error("error",e) );
})();

let gRig, gAnimMachine;
async function dl_files(){
	let dl	= await XhrPromise.get( 
		//"./ninja_run.gltf", "json", "./ninja_run.bin", "arraybuffer",
		//"./cat_walk.gltf", "json", "./cat_walk.bin", "arraybuffer",
		"../walking.gltf", "json", "../walking.bin", "arraybuffer",
		//"./running.gltf", "json", "./running.bin", "arraybuffer",
	);
	
	build_src( dl[0], dl[1] );

	/*
	gAnimMachine.run( 0.2, gRigSrc.pose_a );
	gRig.apply_pose();
	gRig.pose_a.update_world();
	*/
	
	return true;
}


function build_src( json, bin ){
	let anim 		= Gltf.get_animation( "Armature|mixamo.com|Layer0", json, bin );
	let e 			= FungiGLTF.$preview( "src_preview", "Armature", json );
	gRig			= new HumanRig( e, true ).set_feet( "LeftFoot", "RightFoot" );
	gAnimMachine	= new AnimationMachine().set( "walk", anim );
	// gAnimMachine.run( 0.0, gRig.pose_a );
	// gRig.apply_pose();
}



//#############################################################################
let gDone = false;
let gTime = 0;
let gCnt = -1;
let gPath = new Array();

function onDraw( dt, ss ){
	gTime += dt;
	if( gDone == false && gTime >= 0.01 ){
		gTime = 0;
		gCnt++;

		console.log( "View Frame: ", gCnt, gAnimMachine.current.anim.frame_cnt_max );

		if( gAnimMachine.key_frame( gCnt, gRig.pose_a ) ){
			gRig
				.apply_pose()
				.update_pose_world();

			let foot = gRig.get_left_foot();
			gPath.push( foot.world.pos.clone() );
			App.debug.point( foot.world.pos, 0 );
		}else{
			gDone = true;
			console.log( "ANIMATION DONE" );
			process_data();
		}
	}

	/**/
	// gAnimMachine.run( dt, gRigSrc.pose_a );	// Animate and Save to Pose
	// gRigSrc.apply_pose();					// Apply Pose to Src Preview

	App.ecs.sys_run();
}


function process_data(){
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Create a Line Path
	// 
	//App.debug.reset();

	/*
	for( let i=0; i < gPath.length; i++ ){
		gPath[i].z *= 0.8;
		gPath[i].y *= 0.8;
	}
	*/

	for( let i=0; i < gPath.length-1; i++ ){
		App.debug.line( gPath[i], gPath[i+1], 0 );
	}

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Create a flat Float Array out of the Path Vector Array
	let flat_ary	= new Array( gPath.length * 3 ),
		j			= 0;

	for( let i=0; i < gPath.length; i++ ){
		flat_ary[ j++ ] = gPath[ i ][0];
		flat_ary[ j++ ] = gPath[ i ][1];
		flat_ary[ j++ ] = gPath[ i ][2];
	}

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	let data = gAnimMachine.current.anim,
		anim = {
		frame_cnt_max	: data.frame_cnt_max,
		frame_inv		: [ Array.from( data.frame_inv[ 0 ] ) ], 
		time_max		: data.time_max,
		times			: [ Array.from( data.times[ 0 ] ) ],
		tracks			: [
			{ type:"pos", time_idx:0, lerp:"lerp", data: flat_ary },
		]
	};
	console.log( JSON.stringify( anim ) );
}

//############################################################################

class FungiGLTF{
	static $debug( e_name, json, bin, arm_name ){} // Mesh with Armature Preview
	static $( e_name, json, bin ){} // Just the Mesh;
	static $skin( e_name, json, bin, arm_name ){} // Mesh with Armature

	// Armature Preview Only
	static $preview( e_name, arm_name, json ){
		let e		= App.$Draw( e_name ),
			node	= {},
			bones 	= Gltf.getSkin( arm_name, json, node );

		Armature.$( e );
		this.gen_bones( e, bones );
		ArmaturePreview.$( e, "ArmaturePreview", 2 );

		// Set the Entity Transfrom from Armature's Node Transform if available.
		if( node.scl ) e.Node.setScl( node.scl );
		if( node.rot ) e.Node.setRot( node.rot );

		return e;
	}

	/////////////////////////////////////////////////////////////////
	// 
	/////////////////////////////////////////////////////////////////

		// Takes the bones information from gltf and
		// create the Entity Heirarchy of the bones and assign
		// it to the armature.
		static gen_bones( e, bones, def_len=0.3 ){
			let arm = e.Armature;

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Create Bones
			let i, b, ab, bLen = bones.length;
			for( i=0; i < bLen; i++ ){
				b	= bones[i];
				ab	= arm.add_bone( b.name, 1, null, b.idx );
				if( b.rot ) ab.Node.setRot( b.rot );
				if( b.pos ) ab.Node.setPos( b.pos );
				if( b.scl ) ab.Node.setScl( b.scl );
			}

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Setting up Parent-Child
			for( i=0; i < bLen; i++ ){
				b	= bones[ i ];
				ab	= arm.bones[ b.idx ];
				
				// Can not have levels updated automaticly, Callstack limits get hit
				// Instead, using the Level from bones to manually set it.
				if( b.p_idx != null ) arm.bones[ b.p_idx ].Node.add_child( ab, false );

				// Manual set node level, Must do it after addChild, else it will get overwritten.
				ab.Node.level = b.lvl; //TODO THIS ISN"T CORRECT ANYMORE, ROOT BONE NOW LIVES UNDER RENDER ENTITY
			}

			Armature.finalize( e );	// This updates World Transforms

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// With the WorldTransforms update, Calculate the Length of each bone.
			// The IK System needs to know the length of each bone.
			for( i=0; i < bLen; i++ ){
				ab = arm.bones[ i ];

				if( ab.Node.children.length == 0 ){
					ab.Bone.length = def_len;
					continue;
				}

				b = ab.Node.children[0].Node.world;					// First Child's World Space Transform
				ab.Bone.length = ab.Node.world.pos.len( b.pos );	// Distance from Parent to Child
			}
		}
}


//############################################################################

class AnimationMachine{
	constructor(){
		this.current	= null;
		this.cross_to	= null;
		this.cross_t 	= 0;
		this.stack		= {};
	}

	/////////////////////////////////////////////////////////////////
	// 
	/////////////////////////////////////////////////////////////////
		
		// Add a new Animation to the Stack
		set( name, data ){
			this.stack[ name ] = { clock:0, anim:data }; 

			if( !this.current ) this.current = this.stack[ name ];
			return this;
		}

		// Cross Fade into a new Animation
		fade_to( name ){
			let a = this.stack[ name ];
			if( !a ){ console.log("Animation not found on stack: %s", name); return this; }

			a.clock = 0;
			if( !this.current ){ this.current = a; return this; }

			this.cross_to	= a;
			this.cross_t	= 0;
			return this;
		}


	/////////////////////////////////////////////////////////////////
	// 
	/////////////////////////////////////////////////////////////////

		key_frame( ti, pose ){
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			if( ti >= this.current.anim.frame_cnt_max ){
				console.log("key frame index exceeds total key frames.");
				return false;
			}

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			let anim	= this.current.anim,
				q		= new Quat(),
				v		= new Vec3(),
				qi 		= ti*4,
				vi 		= ti*3,
				track;

			for( track of anim.tracks ){
				if( ti >= anim.times[ track.time_idx ].length ) continue;

				switch( track.type ){
					case "rot": pose.set_bone( track.joint_idx, this.quat_buf_copy( track.data, q, qi ) ); break;
					case "pos": pose.set_bone( track.joint_idx, null, this.vec3_buf_copy( track.data, v, vi ) ); break;
				}
			}

			return true;
		}

		// Run animation and save results to pose object
		run( dt, pose ){
			let f_times	= this.frame_times( dt, this.current ),
				anim	= this.current.anim,
				q 		= new Quat(),
				v		= [0,0,0],
				track, frame;

			for( track of anim.tracks ){
				if( track.lerp == "STEP" ) continue; //TODO, add support for this

				frame = f_times[ track.time_idx ]; // [ FA_IDX, FB_IDX, NORM_TIME ]

				switch( track.type ){
					case "rot":
						this.quat_buf_blend( track.data, frame[0]*4, frame[1]*4, frame[2], q );
						pose.set_bone( track.joint_idx, q );
						break;
					case "pos":
						this.vec3_buf_lerp( track.data, frame[0]*3, frame[1]*3, frame[2], v );
						pose.set_bone( track.joint_idx, null, v );
						break;
				}
			}
		}

		// Every animation can have multiple shared time tracks.
		// So we incrmement our animation clock, then for each time
		// track we find between which two frames does the time exist.
		// Then we normalized the time between the two frames.
		// Return: [ [ FA_IDX, FB_IDX, NORM_TIME ], ... ];
		frame_times( dt, data ){
			// Move time forward, loop back on overflow.
			data.clock = (data.clock + dt) % data.anim.time_max;

			// Find the Frames for each group time.
			let j, i, time, fa, fb, ft,
				times	= data.anim.times,
				rtn		= new Array( times.length );

			for( j=0; j < times.length; j++ ){
				time = times[ j ];

				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				// Find the first frame that is less then the clock.
				fa = 0;
				for( i=time.length-2; i > 0; i-- )
					if( time[i] < data.clock ){ fa = i; break; }

				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				// Normalize Time Between Frames
				fb = fa + 1;
				ft = ( data.clock - time[ fa ] ) / ( time[fb] - time[ fa ] );
				//ft = ( anim.clock - time[ fa ] ) * frame_inc[ fa ];
				rtn[ j ] = [ fa, fb, ft ];
			}

			return rtn;
		}


	/*///////////////////////////////////////////////////////////////
	Animation data is saved in a flat array for simplicity & memory sake. 
	Because of that can not easily use Quaternion / Vector functions. So 
	recreate any functions needed to work with a flat data buffer.
	///////////////////////////////////////////////////////////////*/

		quat_buf_copy( buf, q, i ){ return q.set( buf[ i ], buf[ i+1 ], buf[ i+2 ], buf[ i+3 ] ); }

		// Special Quaternion NLerp Function. Does DOT checking & Fix
		quat_buf_blend( buf, ai, bi, t, out ){
			let a_x = buf[ ai ],	// Quaternion From
				a_y = buf[ ai+1 ],
				a_z = buf[ ai+2 ],
				a_w = buf[ ai+3 ],
				b_x = buf[ bi ],	// Quaternion To
				b_y = buf[ bi+1 ],
				b_z = buf[ bi+2 ],
				b_w = buf[ bi+3 ],
				dot = a_x * b_x + a_y * b_y + a_z * b_z + a_w * b_w,
				ti 	= 1 - t,
				s 	= 1;

		    // if Rotations with a dot less then 0 causes artifacts when lerping,
		    // Can fix this by switching the sign of the To Quaternion.
		    if( dot < 0 ) s = -1;
			out[ 0 ] = ti * a_x + t * b_x * s;
			out[ 1 ] = ti * a_y + t * b_y * s;
			out[ 2 ] = ti * a_z + t * b_z * s;
			out[ 3 ] = ti * a_w + t * b_w * s;
			//console.log( "x", out );
			return out.norm();
		}

		//#############################################################

		vec3_buf_copy( buf, v, i ){ return v.set( buf[ i ], buf[ i+1 ], buf[ i+2 ] ); }

		// basic vec3 lerp
		vec3_buf_lerp( buf, ai, bi, t, out ){
			let ti = 1 - t;
			out[ 0 ] = ti * buf[ ai ]		+ t * buf[ bi ];
			out[ 1 ] = ti * buf[ ai + 1 ]	+ t * buf[ bi + 1 ];
			out[ 2 ] = ti * buf[ ai + 2 ]	+ t * buf[ bi + 2 ];
			return out;
		}
}


//############################################################################

class Pose{
	constructor( arm ){
		this.arm			= arm;				// Reference Back to Armature, Make Apply work Easily
		this.bones			= [];				// Recreation of Bone Hierarchy
		this.root_offset	= new Transform();	// Parent Transform for Root Bone ( Mixamo Skeletons need this to render right )

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Create Bone Transform Hierarchy to do transformations
		// without changing the actual armature.
		let b, pi;
		for( let i=0; i < arm.bones.length; i++ ){
			b	= arm.bones[i];
			pi	= ( b.Node.parent && b.Node.parent.Bone )? b.Node.parent.Bone.order : null;

			this.bones[ i ] = {
				chg_state	: 0,								// If Local Has Been Updated
				idx 		: i,								// Bone Index in Armature
				p_idx 		: pi,								// Parent Bone Index in Armature
				len 		: b.Bone.length,					// Length of Bone
				name 		: b.info.name,
				local		: new Transform( b.Bone.bind ),		// Local Transform, use Bind pose as default
				world		: new Transform(),					// Model Space Transform
			};
		}
	}

	/////////////////////////////////////////////////////////////////
	// Setters / Getters
	/////////////////////////////////////////////////////////////////
		
		set_offset( rot=null, pos=null, scl=null ){ this.root_offset.set( rot, pos, scl ); return this; }
		
		set_bone( idx, rot=null, pos=null, scl=null ){
			let b = this.bones[ idx ];
			b.local.set( rot, pos, scl );

			if( rot ) b.chg_state |= Pose.ROT;
			if( pos ) b.chg_state |= Pose.POS;
			if( scl ) b.chg_state |= Pose.SCL;

			return this;
		}

		get_index( bname ){ return this.arm.names[ bname ]; }
		get_bone( bname ){ return this.bones[ this.arm.names[ bname ] ]; }

	/////////////////////////////////////////////////////////////////
	// Methods
	/////////////////////////////////////////////////////////////////

		update_world(){
			for( let b of this.bones ){
				if( b.p_idx != null )	b.world.from_add( this.bones[ b.p_idx ].world, b.local ); // Parent.World + Child.Local
				else					b.world.from_add( this.root_offset, b.local );
			}
			return this;
		}
		
		apply(){
			let i, 
				pb, // Pose Bone
				ab;	// Armature Bone

			for( i=0; i < this.bones.length; i++ ){
				pb = this.bones[ i ];
				
				if( pb.chg_state == 0 ) continue;
				ab = this.arm.bones[ i ];

				if( pb.chg_state & Pose.ROT ) ab.Node.local.rot.copy( pb.local.rot );
				if( pb.chg_state & Pose.POS ) ab.Node.local.pos.copy( pb.local.pos );
				if( pb.chg_state & Pose.SCL ) ab.Node.local.scl.copy( pb.local.scl );
				
				ab.Node.isModified	= true;
				pb.changeState		= 0;
			}

			this.arm.isModified = true;
			return this;
		}

	/////////////////////////////////////////////////////////////////
	// T Pose Helpers
	/////////////////////////////////////////////////////////////////
		static align_chain( pose, dir, ary ){
			let pt		= new Transform(),			// Parent Transform ( Current Bone's Parent );
				ct		= new Transform(),			// Child Transform ( Current Bone )
				aEnd	= ary.length - 1,			// End Index
				f		= new Vec3(),				// Forward
				u		= new Vec3( dir ),			// Up
				l		= new Vec3(),				// Left
				r		= new Quat(),				// Final Rotation
				q		= new Quat(),				// Temp Rotation
				b_idx 	= pose.get_index( ary[0] ),
				b 		= pose.bones[ b_idx ];		// Bone Entity Reference
			
			// Parent Bone's Transform
			Pose.parent_world( pose, b_idx, pt );

			for( let i=0; i <= aEnd; i++ ){
				ct.from_add( pt, b.local );			// Calc current bones world transform
				//App.debug
				//	.point( ct.pos, 2 )
				//	.line( ct.pos, Vec3.add( ct.pos, dir), 0 );
				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				// Up direction is where we need the bone to point to.
				// We then get the bone's current forward direction, use it
				// to get its left, then finish it off by recalculating
				// fwd to make it orthogonal. Want to try to keep the orientation
				// while ( fwd, lft ) realigning the up direction.
				f.from_quat( ct.rot, Vec3.FORWARD ); 		// Find Bone's Forward World Direction
				l.from_cross( u, f ).norm();				// Get World Left
				f.from_cross( l, u ).norm();				// Realign Forward
				r.from_axis( l, u, f );						// Create Rotation from 3x3 rot Matrix
				
				if( Quat.dot( r, ct.rot ) < 0 ) r.negate();	// Do a Inverted rotation check, negate it if under zero.
				
				r.pmul( q.from_invert( pt.rot ) );			// Move rotation to local space
				pose.set_bone( b.idx, r );		// Update Pose with new ls rotation
				
				//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				// If not the last bone, take then the new rotation to calc the next parents
				// world space transform for the next bone on the list.
				if( i != aEnd){
					pt.add( r, b.local.pos, b.local.scl );
					b = pose.get_bone( ary[i+1] );
				}
			}
		}

		static align_foot_forward( pose, foot ){
			let pt	= new Transform(),
				ct	= new Transform(),
				v	= new Vec3(),
				q	= new Quat(),
				b	= pose.get_bone( foot );

			this.parent_world( pose, b.idx, pt, ct );	// Get the Parent and Child Transforms. e.Armature,
			
			ct.transformVec( [0,b.len,0], v );			// Get the Tails of the Bone
			v.sub( ct.pos );							// Get The direction to the tail
			v[1] = 0;									// Flatten vector to 2D by removing Y Position
			v.norm();									// Make it a unit vector
			q	.from_unit_vecs( v, Vec3.FORWARD )		// Rotation needed to point the foot forward.
				.mul( ct.rot )							// Move WS Foot to point forward
				.pmul( pt.rot.invert() );				// To Local Space
			pose.set_bone( b.idx, q );		// Save to Pose
		}

		static parent_world( pose, b_idx, pt, ct=null ){ //arm,
			let b	= pose.bones[ b_idx ],
				ary	= [];

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			// Move up the Bone Tree
			while( b.p_idx != null ){
				ary.push( b.p_idx );
				b = pose.bones[ b.p_idx ];
			}

			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			let i 	= ary.length - 1,
				pb	= pose.bones;

			pt.copy( pose.root_offset ); // Use the offset as a starting point
			
			for( i; i > -1; i-- ) pt.add( pose.bones[ ary[i] ].local );	// Then add all the children bones
			
			//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			if( ct ) ct.from_add( pt, pose.bones[ b_idx ].local );		// Then add child current local transform to the parent's
		}
}

Pose.ROT = 1;
Pose.POS = 2;
Pose.SCL = 4;


//############################################################################

class Chain{
	constructor( ik_align_axis="z" ){		
		this.bones			= [];			// Index to a bone in an armature / pose
		this.cnt			= 0;			// How many Bones in the chain
		this.len 			= 0;			// Chain Length
		this.len_sqr		= 0;			// Chain Length Squared, Cached for Checks without SQRT

		this.ik_align_axis	= ik_align_axis;
	}

	set_bones( pose, b_names ){
		let n, b;
		for( n of b_names ){
			b = pose.get_bone( n );
			this.len += b.len;
			this.bones.push( b.idx );
		}
		this.cnt		= b_names.length;
		this.len_str	= this.len ** 2;
	}
}

class HumanRig{
	constructor( e, use_root_offset=false ){
		this.entity = e;
		this.arm 	= e.Armature;

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		this.bind_pose	= new Pose( this.arm );
		this.pose_a		= new Pose( this.arm );

		if( use_root_offset ){
			this.bind_pose.set_offset( e.Node.local.rot, null, e.Node.local.scl );
			this.pose_a.set_offset( e.Node.local.rot, null, e.Node.local.scl );
		}

		this.bind_pose.update_world();

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		this.arm_l 	= new Chain( "x" );
		this.arm_r 	= new Chain( "x" );
		this.leg_l 	= new Chain( "z" );
		this.leg_r 	= new Chain( "z" );
		this.spine 	= new Chain( "z" );

		this.hip 	= null;
		this.foot_l = null;
		this.foot_r = null;
	}

	apply_pose(){ this.pose_a.apply(); return this; }

	/////////////////////////////////////////////////////////////////
	// 
	/////////////////////////////////////////////////////////////////
		set_arm_l(){ this.arm_l.set_bones( this.bind_pose, arguments ); return this; }
		set_arm_r(){ this.arm_r.set_bones( this.bind_pose, arguments ); return this; }
		set_leg_l(){ this.leg_l.set_bones( this.bind_pose, arguments ); return this; }
		set_leg_r(){ this.leg_r.set_bones( this.bind_pose, arguments ); return this; }
		set_feet( fl, fr ){
			this.foot_l = this.bind_pose.get_index( fl );
			this.foot_r = this.bind_pose.get_index( fr );
			return this;
		}

		get_left_foot(){ return this.pose_a.bones[ this.foot_l ]; }

		update_pose_world(){ this.pose_a.update_world(); return this; }

	/////////////////////////////////////////////////////////////////
	// 
	/////////////////////////////////////////////////////////////////		
		gen_tpose(){
			let chary = ( chain )=>{
				let ary = [];
				for( let i of chain.bones ) ary.push( this.bind_pose.bones[ i ].name );
				return ary;
			};

			Pose.align_chain( this.bind_pose, Vec3.DOWN, chary( this.leg_l ) );
			Pose.align_chain( this.bind_pose, Vec3.DOWN, chary( this.leg_r ) );
			Pose.align_chain( this.bind_pose, Vec3.RIGHT, chary( this.arm_r ) );
			Pose.align_chain( this.bind_pose, Vec3.LEFT, chary( this.arm_l ) );
			Pose.align_foot_forward( this.bind_pose, this.foot_l.name );
			Pose.align_foot_forward( this.bind_pose, this.foot_r.name );

			this.bind_pose.update_world();
			this.bind_pose.apply();
			return this;
		}
}

</script><body>
</body></html>