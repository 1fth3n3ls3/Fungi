<!DOCTYPE html><html><head><title></title></head><script type="module">
import App, { AppBuilder, Material } from "../fungi/engine/App.js";
import Maths, { Quat, Vec3 } from "../fungi/maths/Maths.js";
import Transform	from "../fungi/maths/Transform.js";
import DVerts 		from "../fungi/engine/ecs/DynamicVerts.js";

import Animation 	from "../fungi.animation/Animation.js";
import SingleTrack 	from "../fungi.animation/SingleTrack.js";

import XhrPromise	from "../fungi.misc/XhrPromise.js";
import FungiGLTF	from "../fungi.misc/FungiGLTF.js";

import Pose			from "./Pose.js";
import HumanRig		from "./HumanRig.js";
import IKTarget		from "./IKTarget.js";

import Overlay 		from "../fungi.misc/Overlay.js";

//#############################################################################
(function(){new AppBuilder()
	.launch( 1 )
	.load_armature()
	.download( dl=>dl.addGrp( "shader", 
		"../fungi/shaders/VecWColor.txt", 
		"../fungi.armature/shaders/ArmaturePreview.txt", 
		"../fungi.armature/shaders/ArmatureSkinPhong.txt", 
	) ) 
	.load_scene( true, true, true )
	.set_camera( -50, 10, 3, 0, 0.3, 0 )
	.add( dl_files )
	.render_loop( onDraw )
	//.render_on_mouse( onDraw )
	.build().catch( (e)=>console.error("error",e) );
})();

//#############################################################################
function onDraw( dt, ss ){
	run_animation( dt );
	App.ecs.sys_run();
}

function run_animation( dt ){
	gAnimateA.next_frame( dt * ANIM_SPEED );
	gMoveA.Node.setPos( gAnimateA.run() );
	gMoveB.Node.setPos( gAnimateA.run( 15 ).mul([-1,1,1]) );

	Kinematics.next();
}


//#############################################################################
let gRig, gAnimateA, gMoveA, gAnimateB, gMoveB, gStatA, gStatB;

async function dl_files(){
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	let dl	= await XhrPromise.get( "../robo_trex.gltf", "json", "../robo_trex.bin", "arraybuffer" );
	let mat = Material.clone( "ArmatureSkinPhong", "RexMat" ).opt_blend( true ).update_uniform( "uBaseColor", "b0b0b0aa" );
	
	let e = FungiGLTF.$debug( "arm_debug", dl[0], dl[1], "Armature", mat );
	//let e = FungiGLTF.$preview( "src_preview", "Armature", dl[0] );

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	gRig = new HumanRig( e )
		.set_hip( "hip" )
		//.set_chain( "tail", ["tail_1","tail_2","tail_3","tail_4","tail_5","tail_6","tail_7"] )
		.set_leg_l( "LeftUpLeg", "LeftKnee", "LeftShin" )
		.set_leg_r( "RightUpLeg", "RightKnee", "RightShin" )
		.set_feet( "LeftFoot", "RightFoot" )
		.gen_tpose()
		.finalize();


	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	setup_anim();
	setup_ui();

	//run_animation( 0.6 );	
	return true;
}



function test_feet(){
	let bind = gRig.bind_pose,
		chain = gRig.leg_l,
		b;

	/*
	for( let i of chain.bones ){
		b = bind.bones[i];
		App.debug.point( b.world.pos, 8 );
	}
	*/

	b = bind.bones[ gRig.foot_l.idx ];

	App.debug.point( b.world.pos, 8 );
	//App.debug.quat( b.world.rot, b.world.pos );

	let dir		= Vec3.transform_quat( Vec3.UP, b.world.rot ),
		angle	= Vec3.angle( Vec3.FORWARD, dir ),
		dot		= Vec3.dot( dir, Vec3.UP );
	if( dot < 0 ) angle = -angle;

	gRig.foot_l = angle;

	console.log( dot, angle, angle * 180 / Math.PI );

	App.debug.line( b.world.pos, Vec3.add( b.world.pos, dir ) );
	App.debug.line( b.world.pos, Vec3.add( b.world.pos, Vec3.FORWARD ), 1 );

	// Get model Space UP Direction of Foot.
	// To do a dot test againt world up. If positive its upwards, else downward of the forward direction.
	// Take the Bone's model space up and get the angle from worldspace forward.
	// The angle is the offset to make it straight.
	// Foot Data { idx:, offset_angle: }
}

function setup_anim(){
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	draw_path( WALK_CYCLE.tracks[0].data, false, true );
	//WALK_CYCLE_S.tracks[0].data = scale_path( WALK_CYCLE.tracks[0].data, 0.5, 0.5, true );

	gMoveA = DVerts.$( App.$Draw( "pnta" ) );
	gMoveB = DVerts.$( App.$Draw( "pntb" ) );
	gMoveA.DynamicVerts.raw_pnt( 0, 0, 0, 8 );
	gMoveB.DynamicVerts.raw_pnt( 0, 0, 0, 7 );

	gStatA = DVerts.$( App.$Draw( "stata" ) );
	gStatB = DVerts.$( App.$Draw( "statb" ) );
	gStatA.DynamicVerts.raw_pnt( 0, 0, 0, 0 );
	gStatB.DynamicVerts.raw_pnt( 0, 0, 0, 1 );

	gStatA.Node.setPos( 0.3, 0.0, -0.8 );
	gStatB.Node.setPos( -0.3, 0.0, -0.8 );

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	gAnimateA = new SingleTrack()
		.set( WALK_CYCLE_S );
}

function setup_ui(){
	let eInt = (e)=>parseInt(e.srcElement.value);
	let eRad = (e)=>Maths.toRad(parseFloat(e.srcElement.value));
	let eFloat = (e)=>parseFloat(e.srcElement.value);
	
	//add_range( name, value=0, min=0, max=1, step=0.01, func )

	let ol = new Overlay();
	ol 	.load_css( "../fungi.misc/Overlay.css" )
		.add_range( "Z Stride Scale", 1, 0.1, 2, .1, e=>mod_scale_path(eFloat(e),0) )
		.add_range( "Y Stride Scale", 1, 0.1, 2, .1, e=>mod_scale_path(eFloat(e),1) )
		.add_range( "Animation Speed", 0.7, 0.1, 2, .1, e=>mod_anim_speed(eFloat(e)) )
		/*.add_range( "Eye Lid - Upper", 0, 0, 1, .1, e=>eye_lid_upper(eFloat(e)) )
		.add_range( "Eye Lid - Lower", 0, 0, 1, .1, e=>eye_lid_lower(eFloat(e)) )
		.add_range( "Nose", 0, -22, 20, .1, e=>mod_nose(eFloat(e)) )

		.add_range( "Arm Angle", 0, 0, 80, 5, (e)=>{
			let rad = Maths.toRad( eInt(e) );
			g_arm_rot_l.setAxisAngle( [0,0,1], rad );
			g_arm_rot_r.setAxisAngle( [0,0,1], -rad );
		})
		
		.add_range( "Spine Angle", 0, 0, 30, 1, (e)=>{ g_spine_rad = eRad(e); })
		.add_range( "Spine Cycle", 2, 1, 4, 1, (e)=>{ g_spine_cycle = eInt(e); })
		.add_range( "Head Angle", 0, 0, 30, 1, (e)=>{ g_neck_rad = eRad(e); })
		.add_range( "Spine Cycle", 2, 1, 4, 1, (e)=>{ g_neck_cycle = eInt(e); })
		*/
		;
}

let SCALE_Z = 1, SCALE_Y = 1;
function mod_scale_path( s, axis=0 ){
	if( axis == 0 ) SCALE_Z = s;
	else 			SCALE_Y = s;
	App.debug.reset();
	scale_path( WALK_CYCLE.tracks[0].data, SCALE_Z, SCALE_Y, true, WALK_CYCLE_S.tracks[0].data );
}

let ANIM_SPEED = 0.7;
function mod_anim_speed( s ){
	ANIM_SPEED = s;
}

//#############################################################################

function draw_path( vec_buf, pnt=true, line=true, clr=0 ){
	let a 		= new Vec3();
	let b 		= new Vec3();
	let cnt		= vec_buf.length;
	let elm_cnt = cnt / 3;
	let i;

	if( pnt ){
		for( i=0; i < cnt; i+=3 ) App.debug.point( a.from_buf( vec_buf, i ), clr );
	}
	
	if( line ){
		for( i=0; i < elm_cnt-1; i++ ){
			a.from_buf( vec_buf, i*3 );
			b.from_buf( vec_buf, (i+1)*3 );
			App.debug.line( a, b, clr );
		}
	}
}

function scale_path( buf, sz=1, sy=1, do_y_fix=true, out ){
	let ary		= out || new Float32Array( buf.length );
	let min_y	= Number.MAX_SAFE_INTEGER;

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	for( let i=0; i < buf.length; i+=3 ){
		ary[ i ]	= buf[ i ];
		ary[ i+1 ]	= buf[ i+1 ] * sy;
		ary[ i+2 ]	= buf[ i+2 ] * sz;

		if( ary[ i+1 ] < min_y ) min_y = ary[ i+1 ];
	}

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	if( do_y_fix ){
		let y_dif = min_y - WALK_MIN_Y;
		for( let i=1; i < ary.length; i+=3 ) ary[ i ] -= y_dif;
	}

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	draw_path( ary, false, true, 1 );
	return ary;
}

function y_min( vec_buf ){
	let min = Number.MAX_SAFE_INTEGER;
	for( let i=1; i < vec_buf.length; i+=3 ) if( vec_buf[i] < min ) min = vec_buf[i];
	// App.debug.rawPoint( 0.2, min, 0, 7 );
	return min;
}

function buf_add( buf, v ){
	for( let i=0; i < buf.length; i+=3 ){
		buf[ i ]	+= v[ 0 ];
		buf[ i+1 ] 	+= v[ 1 ];
		buf[ i+2 ] 	+= v[ 2 ];
	}
}

function buf_mul( buf, v, out ){
	out = out || buf;
	for( let i=0; i < buf.length; i+=3 ){
		out[ i ]	*= v[ 0 ];
		out[ i+1 ] 	*= v[ 1 ];
		out[ i+2 ] 	*= v[ 2 ];
	}
}


//#############################################################################
const WALK_CYCLE = {
	"frame_cnt":32,
	"time_max":1.0333333333333334,
	"frame_inv":[
		[29.999998092651367,29.999998092651367,30.000001907348633,29.9999942779541,30.000001907348633,30.000001907348633,30.000001907348633,29.999988555908203,30.000001907348633,30.000001907348633,30.000001907348633,30.000001907348633,30.000001907348633,30.000001907348633,30.000001907348633,29.999975204467773,30.000028610229492,29.999975204467773,30.000028610229492,29.999975204467773,30.000028610229492,29.999975204467773,30.000028610229492,29.999975204467773,30.000028610229492,29.999975204467773,30.000028610229492,29.999975204467773,30.000028610229492,29.999975204467773,30.000028610229492]
	],
	"times":[
		[0,0.03333333507180214,0.06666667014360428,0.10000000149011612,0.13333334028720856,0.1666666716337204,0.20000000298023224,0.23333333432674408,0.2666666805744171,0.30000001192092896,0.3333333432674408,0.36666667461395264,0.4000000059604645,0.4333333373069763,0.46666666865348816,0.5,0.5333333611488342,0.5666666626930237,0.6000000238418579,0.6333333253860474,0.6666666865348816,0.699999988079071,0.7333333492279053,0.7666666507720947,0.800000011920929,0.8333333134651184,0.8666666746139526,0.8999999761581421,0.9333333373069763,0.9666666388511658,1,1.0333333015441895]
	],
	"tracks":[
		{
			"type":"pos",
			"time_idx":0,
			"interp":"lerp",
			"data":[0.07064038515090942,0.19373536109924316,-0.057582780718803406,0.07025916874408722,0.15342551469802856,0.05687040090560913,0.07546158134937286,0.12373906373977661,0.18048539757728577,0.08816960453987122,0.12958106398582458,0.2974770963191986,0.10484816133975983,0.1486959159374237,0.39396190643310547,0.11279416084289551,0.16305223107337952,0.45192867517471313,0.10969524085521698,0.15113615989685059,0.4557003378868103,0.10315526276826859,0.1229504942893982,0.42953455448150635,0.09689415991306305,0.09816184639930725,0.3997156322002411,0.095611572265625,0.08730313181877136,0.36611947417259216,0.09552071988582611,0.08730411529541016,0.3112850785255432,0.09613831341266632,0.08729535341262817,0.2558574080467224,0.0964774563908577,0.08729508519172668,0.20024073123931885,0.09639546275138855,0.08729451894760132,0.14447155594825745,0.09617869555950165,0.08729520440101624,0.08869943022727966,0.09607300907373428,0.08729511499404907,0.033034175634384155,0.09591510146856308,0.08729526400566101,-0.022682130336761475,0.0956040620803833,0.08729517459869385,-0.078647181391716,0.09524963796138763,0.0873211920261383,-0.13484032452106476,0.09429754316806793,0.08885818719863892,-0.19086739420890808,0.09258563071489334,0.09234970808029175,-0.24678170680999756,0.09137961268424988,0.09552299976348877,-0.3026721477508545,0.09029284864664078,0.10294151306152344,-0.3551836609840393,0.0888751894235611,0.11725258827209473,-0.3984808921813965,0.0842810720205307,0.13574129343032837,-0.4284011721611023,0.08056467026472092,0.17638453841209412,-0.43701159954071045,0.07900793850421906,0.22734610736370087,-0.41232919692993164,0.0749068409204483,0.2670424282550812,-0.364707350730896,0.06989461928606033,0.2797327935695648,-0.30498701333999634,0.06637650728225708,0.26702067255973816,-0.23438240587711334,0.06571738421916962,0.23567381501197815,-0.15287458896636963,0.070640429854393,0.1937353014945984,-0.057582855224609375]
		}
	]
};

buf_add( WALK_CYCLE.tracks[0].data, [0.18, -0.08729451894760132, 0 ] );
//buf_mul( WALK_CYCLE.tracks[0].data, [ 1, 1.9, 1.7 ] );
//buf_mul( WALK_CYCLE.tracks[0].data, [ 1, 0.3, 0.3 ] );

const WALK_MIN_Y	= y_min( WALK_CYCLE.tracks[0].data );
const WALK_CYCLE_S	= new Animation( WALK_CYCLE );

//console.log( WALK_MIN_Y );


//#############################################################################

let foot_l_down = false;
let foot_r_down = false;
let foot_min_y = 0.03;

class Kinematics{
	static next(){
		this.ik_leg( gMoveA.Node.local.pos, gRig.leg_l );
		this.ik_leg( gMoveB.Node.local.pos, gRig.leg_r );
		this.update_foot_status();
		
		if( foot_l_down ) this.target.foot_ik( gRig.foot_l.idx, gRig.bind_pose, gRig.pose_a, Vec3.FORWARD );
		if( foot_r_down ) this.target.foot_ik( gRig.foot_r.idx, gRig.bind_pose, gRig.pose_a, Vec3.FORWARD );

		gRig.apply_pose();
	}

	static update_foot_status(){
		let foot_lpos = gRig.calc_foot_l();
		let foot_rpos = gRig.calc_foot_r();

		if( foot_lpos.y <= foot_min_y && !foot_l_down ){	foot_l_down = true; gStatA.Node.setPos( 0.3, 0.0, -0.8 ); }
		else if( foot_lpos.y > foot_min_y && foot_l_down ){	foot_l_down = false; gStatA.Node.setPos( 0.3, 0.5, -0.8 ); }

		if( foot_rpos.y <= foot_min_y && !foot_r_down ){	foot_r_down = true; gStatB.Node.setPos( -0.3, 0.0, -0.8 ); }
		else if( foot_rpos.y > foot_min_y && foot_r_down ){	foot_r_down = false; gStatB.Node.setPos( -0.3, 0.5, -0.8 ); }
	}


	static ik_leg( target_pos, leg, foot=null ){
		Pose.parent_world( gRig.bind_pose, leg.bones[0], this.ptran, this.ctran );	// Get the Starting Position of the Thigh Bone
		this.target.from_pos( this.ctran.pos, target_pos, Vec3.FORWARD );				// Setup Our IK target
		this.target.three_bone( leg, gRig.bind_pose, gRig.pose_a, this.ptran );		// Execute IK on Chain
	}
}
Kinematics.ptran 	= new Transform();
Kinematics.ctran 	= new Transform();
Kinematics.target	= new IKTarget();

</script><body>
</body></html>