<!DOCTYPE html><html><head><title></title></head><script type="module">
import App, { Material } from "../fungi/engine/App.js";
import Maths, { Quat, Vec3 } from "../fungi/maths/Maths.js";
import Transform		from "../fungi/maths/Transform.js";
import Points 			from "../fungi/engine/ecs/Points.js";
import Lines 			from "../fungi/engine/ecs/Lines.js";

import Vec3Spring		from "../fungi/data/Vec3Spring.js";

import Animation 		from "../fungi.animation/Animation.js";
import AnimationState	from "../fungi.animation/AnimationState.js";

import XhrPromise		from "../fungi.misc/XhrPromise.js";
import FungiGLTF		from "../fungi.misc/FungiGLTF.js";
import FungiMesh		from "../fungi.misc/FungiMesh.js";

import Pose				from "./Pose.js";
import HumanRig			from "./HumanRig.js";
import IKTarget			from "./IKTarget.js";

//#############################################################################
App.builder().launch().load_armature()
	.download( dl=>dl.addGrp( "shader", 
		"../fungi/shaders/VecWColor.txt", 
		"../fungi.armature/shaders/ArmaturePreview.txt", 
		"../fungi.armature/shaders/ArmatureSkinPhong.txt", 
	) ) 
	.load_scene( true, true, true )
	.set_camera( -50, 10, 4, 0, 0.8, 0 )
	.add( init )
	.render_loop( on_draw )
	//.render_on_mouse( on_draw )
	.build().catch( (e)=>console.error("error",e) );


//#############################################################################
function on_draw( dt, ss ){
	if( RUN_ANIM ) run_animation( dt );
	App.ecs.sys_run();
}


//#############################################################################
let gAnimator, gRig_Animator, gIK_Compute, 
	gRigA, gRigB,
	gTargetA, gTargetB;

let RUN_ANIM = false,
	TARGET_A = false,
	TARGET_B = true;

async function init(){
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	let dl_ary = ["../walking.gltf", "json", "../walking.bin", "arraybuffer"];
	if( TARGET_A || TARGET_B )	dl_ary.push( "../files/models/vegeta.txt", "text", "../files/models/vegeta.bin", "arraybuffer" ); //files/models/
	if( TARGET_B ) 				dl_ary.push( "../robo_trex.gltf", "json", "../robo_trex.bin", "arraybuffer" );

	let dl = await XhrPromise.get.apply( XhrPromise, dl_ary );

	IK_Visualize.init();
	let mat = Material
		.clone( "ArmatureSkinPhong", "RexMat" )
		.update_uniform( "uBaseColor", "b0b0b0aa" )
		.opt_blend( true );

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	setup_animation( dl[0], dl[1] );
	if( TARGET_A ) setup_target_a( dl[2], dl[3], mat );
	if( TARGET_B ) setup_target_b( dl[4], dl[5], mat );

	gIK_Compute = new IKRig_Compute( gRig_Animator );
	
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//run_animation( 0.7 );

	return true;
}


//#############################################################################

function run_animation( dt ){
	gAnimator.run( dt );		// Run Animaton, Set Changes to Rig's Pose

	gRig_Animator
		.update_world()			// Calc Model Space for all the bones
		.apply_pose();			// Apply Pose to Armature

	gIK_Compute.update( dt );	// Take Model Space Src Rig and calc some IK Information
	//IK_Visualize.update();		// Visually Apply IK Info to Src Model

	if( TARGET_A ){			
		gTargetA.update( gIK_Compute );	// Run IK On Target
		gRigA.apply_pose();				// Update Armature
	}

	if( TARGET_B ){
		gTargetB.update( gIK_Compute );	// Run IK On Target
		gRigB.apply_pose();				// Update Armature
	}
}

function setup_animation( json, bin ){
	let e = FungiGLTF.$preview( "src_preview", "Armature", json );
	e.info.active = false;
	
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	gRig_Animator = new HumanRig( e, true )
		.set_hip( "Hips" )
		.set_arm_l( ["LeftArm", "LeftForeArm"] )
		.set_arm_r( ["RightArm", "RightForeArm"] )
		.set_leg_l( ["LeftUpLeg", "LeftLeg"] )
		.set_leg_r( ["RightUpLeg", "RightLeg"] )
		.set_foot( 0, "LeftFoot" )
		.set_foot( 1, "RightFoot" );

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	gAnimator = new AnimationState();
	gAnimator
		.use_pose_handler( gRig_Animator.pose_a )
		.add_stack( "walk", FungiGLTF.animation( "Armature|mixamo.com|Layer0", json, bin ) );
}

function setup_target_a( txt, bin, mat ){
	let e = FungiMesh.$debug( "TargetA", mat, txt, bin );
	//let e = FungiMesh.$preview( "TargetA", txt );

	gRigA = new HumanRig( e )
		.set_hip( "Hips" )
		.set_leg_l( "LeftUpLeg", "LeftLeg" )
		.set_leg_r( "RightUpLeg", "RightLeg" )
		.set_arm_l( "LeftArm", "LeftForeArm" )
		.set_arm_r( "RightArm", "RightForeArm" )
		.set_feet( "LeftFoot", "RightFoot" )
		.gen_tpose();

	//e.Node.setPos( 1.3, 0, 0 );

	gTargetA = new IKRig_Target( gRig_Animator, gRigA );
}

function setup_target_b( json, bin, mat ){
	let e = FungiGLTF.$debug( "TargetA", json, bin, "Armature", mat );
	//let e = FungiGLTF.$preview( "TargetB", "Armature", json );

	gRigB = new HumanRig( e )
		.set_hip( "hip" )
		.set_leg_l( ["LeftUpLeg", "LeftKnee", "LeftShin"], true )
		.set_leg_r( ["RightUpLeg", "RightKnee", "RightShin"], true )
		.set_foot( 0, "LeftFoot", true, false, true )
		.set_foot( 1, "RightFoot" )
		.ready();

	//e.Node.setPos( -1.3, 0, 0 );

	gTargetB = new IKRig_Target( gRig_Animator, gRigB, 1, true, 0.06 );
}


//#############################################################################
// Overlay some visuals over the src armature to see the IK Target Information
class IK_Visualize{
	static init(){
		this.pnt = Points.$( null, 10, 10 ).Points;
		this.lin = Lines.$( null, 10 ).Lines;
	}

	static update(){
		App.debug.reset();
		this.pnt.reset();
		this.lin.reset();

		let rik = gIK_Compute;

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		this.update_hip( rik )

		this.update_limb( this.leg_l, rik.leg_l, rik.rig.leg_l, rik.rig.foot_l.idx, rik.rig.pose_a );
		this.update_limb( this.leg_r, rik.leg_r, rik.rig.leg_r, rik.rig.foot_r.idx, rik.rig.pose_a );

		this.update_foot( rik.rig.foot_l.idx, rik.foot_l_dir, rik.rig.pose_a );
		this.update_foot( rik.rig.foot_r.idx, rik.foot_r_dir, rik.rig.pose_a );
		
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		this.pnt.update();
		this.lin.update();
	}

	static update_hip( rik ){
		let hip = rik.rig.get_hip();
		this.pnt.add_diamond( hip.world.pos, "orange", 18 );

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// See Rotation Axis
		this.show_axis( rik.hip_dif_rot, Vec3.add( hip.world.pos, [0,0,0.05] ) );
	}

	static show_axis( rot, pos, scl=0.08 ){
		let dir = new Vec3();

		dir.from_quat( rot, Vec3.FORWARD ).scale( scl ).add( pos );
		this.lin.add( pos, dir, "green", null, false );

		dir.from_quat( rot, Vec3.LEFT ).scale( scl ).add( pos );
		this.lin.add( pos, dir, "red", null, false );

		dir.from_quat( rot, Vec3.UP ).scale( scl ).add( pos );
		this.lin.add( pos, dir, "blue", null, false );
	}

	static update_limb( ui, ik, chain, end, pose ){
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Display Limp Points
		let a = pose.bones[ chain.bones[0] ],	// Starting Point
			b = pose.bones[ chain.bones[1] ],	// Bending Point
			c = pose.bones[ end ];				// End Point

		this.pnt.add_circle( a.world.pos, "green", 14 );
		this.pnt.add_circle( b.world.pos, "cyan", 8 );
		this.pnt.add_circle( c.world.pos, "red", 14 );

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Display Lines
		const JNT_LEN = 0.2;
		const end_pos = new Vec3();
		const jnt_dir = new Vec3();

		let len = ik.len_scale * ik.len; //chain.len
		end_pos.from_scale( ik.fwd, len ).add( a.world.pos );

		jnt_dir.from_scale( ik.up, JNT_LEN ).add( b.world.pos );
		//jnt_dir.from_scale( ik.joint_dir.pos, JNT_LEN ).add( b.world.pos );

		this.lin.add( a.world.pos, end_pos, "green", "red" );
		this.lin.add( b.world.pos, jnt_dir, "cyan" );
	}

	static update_foot( b_idx, dir, pose ){
		let b = pose.bones[ b_idx ];
		let v = Vec3.scale( dir, 0.3 ).add( b.world.pos );
		this.lin.add( b.world.pos, v, "cyan" );
	}
}

//#############################################################################

// Take an Animated Rig and compute IK Target Information from its pose.
//const SMOOTHING_DAMP 	= 1.0;
//const SMOOTHING_OSC		= 2;

class IKRig_Compute{
	constructor( r_src ){
		this.rig = r_src;

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Setup Hip
		let h_idx = r_src.hip.idx;
		this.hip_bind_pos 	= new Vec3( r_src.bind_pose.bones[ h_idx ].world.pos );
		this.hip_bind_rot 	= new Quat( r_src.bind_pose.bones[ h_idx ].world.rot ).invert();

		this.hip_dif_pos 	= new Vec3(); // Position Difference from Bind to Pose
		this.hip_dif_rot	= new Quat(); // Rotation Difference from Bind to Pose

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Setup Legs		
		this.leg_l 		= this.new_limb( "LeftUpLeg", "LeftFoot" ); //, Vec3.FORWARD
		this.leg_r		= this.new_limb( "RightUpLeg", "RightFoot" ); //, Vec3.FORWARD 
		this.leg_dir	= Vec3.BACK;

		this.foot_l_dir	= new Vec3();
		this.foot_r_dir	= new Vec3();
	}

	new_limb( bname_0, b_name1 ){ //, j_dir
		return { 
			fwd			: new Vec3(), 
			up			: new Vec3(), 
			len_scale	: 1, 
			len 		: this.len_between_bones( "LeftUpLeg", "LeftFoot" ),
			//joint_dir	: new Vec3Spring( SMOOTHING_OSC, SMOOTHING_DAMP, j_dir ),
		}
	}

	// Chain Length isn't reliable when the mesh has an offset scale.
	// Rig Bind pose should be scaled, so calc distance between two joints.
	len_between_bones( n0, n1 ){
		let a = this.rig.bind_pose.get_bone( n0 ),
			b = this.rig.bind_pose.get_bone( n1 );
		return Vec3.len( a.world.pos, b.world.pos );
	}

	update( dt ){ 
		//App.debug.reset();
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		let b = this.rig.get_hip();
		this.hip_dif_pos.from_sub( b.world.pos, this.hip_bind_pos );
		this.hip_dif_rot.from_mul( this.hip_bind_rot, b.world.rot ); // Prob not the best way to get rotation, Not isolating bone but it is a hip so it might be ok.

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		this.ik_compute_limb( this.rig.leg_l, this.rig.foot_l.idx, this.leg_l, dt );
		this.ik_compute_limb( this.rig.leg_r, this.rig.foot_r.idx, this.leg_r, dt );

		this.ik_compute_foot( this.rig.foot_l.idx, this.foot_l_dir );
		this.ik_compute_foot( this.rig.foot_r.idx, this.foot_r_dir );
	}

	// Chain is the arm or leg bones, where end is the hand or foot.
	ik_compute_limb( chain, end, out, dt ){
		let a, b, c,
			p = new Vec3();

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Get Reference to the 3 Points of the Limb. Forms a Triangle
		a = this.rig.get_bone( chain.bones[0] );
		b = this.rig.get_bone( chain.bones[1] );
		c = this.rig.get_bone( end );

		//App.debug.line( a.world.pos, Vec3.transform_quat( Vec3.FORWARD, a.world.rot ).add(a.world.pos), 0 );

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Calculate the Forward IK Direction and the Distance to end effector.
		let dst = out.fwd
			.from_sub( c.world.pos, a.world.pos ) 	// Calc Forward Direction
			.len();									// Then Get the Length of the segment.

		out.fwd.norm();								// Normalizing the forward direction
		out.len_scale = dst / out.len;				// Scale he distance based on total limb length

		//p.from_sub( b.world.pos, a.world.pos );	// Calculate the Joint Dir (Knee, Elbow)  ITS JITTERY
		//p.from_cross( p, out.fwd );
		//out.up.from_cross( out.fwd, p ).norm();

		out.up.from_quat( a.world.rot, this.leg_dir ); // Calculate the Joint Dir (Knee, Elbow)  BETTER
		
		//out.joint_dir								// Smooth movement of the Up direction since it can be jittery
		//	.set_target( out.up )				
		//	.update( dt );
		//console.log( "len_scale", dst, chain.len, out.len_scale );
	}

	ik_compute_foot( b_idx, dir ){
		let b = this.rig.pose_a.bones[ b_idx ];		
		//App.debug.point( b.world.pos );
		dir.from_quat( b.world.rot, Vec3.UP );//.scale(0.3)//.add( b.world.pos );
		//App.debug.line( b.world.pos, dir );
	}
}

// Apply IK Information to a Pose.
class IKRig_Target{
	constructor( r_src, r_tar, leg_solver=0, use_hip_height=false, grd_offset=0 ){
		this.target		= new IKTarget();
		this.rig 		= r_tar;

		this.pt			= new Transform();
		this.ct			= new Transform();
		this.target_pos	= new Vec3();

		this.grd_offset = grd_offset;
		this.leg_solver = leg_solver;

		//this.hip_bind_pos = r_tar.bind_pose.bones[ r_tar.hip.idx ].world.pos.clone();
		
		this.ik_leg_l_len = (use_hip_height) ? r_tar.bind_pose.bones[ r_tar.hip.idx ].world.pos.y : 0;
		this.ik_leg_l_len -= this.grd_offset;

		this.foot_l_up = this.setup_foot( this.rig.foot_l.idx ); //This information should be in the Rig, not calculated here.
		this.foot_r_up = this.setup_foot( this.rig.foot_r.idx );

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Hip Information
		let ia	= r_src.hip.idx,
			ib	= r_tar.hip.idx,
			a	= r_src.bind_pose.bones[ia].world.pos.clone().near_zero(),
			b	= r_tar.bind_pose.bones[ib].world.pos.clone().near_zero();
		this.hip_scale = new Vec3().from_div( b, a );
	}

	/////////////////////////////////////////////////////////////////
	//
	/////////////////////////////////////////////////////////////////
		update( ik ){
			this.run_hip( ik );
			this.run_limb( this.rig.leg_l, ik.leg_l );
			this.run_limb( this.rig.leg_r, ik.leg_r );

			this.run_foot( this.rig.foot_l, ik.foot_l_dir, this.foot_l_up );
			this.run_foot( this.rig.foot_r, ik.foot_r_dir, this.foot_r_up );
		}

	/////////////////////////////////////////////////////////////////
	//
	/////////////////////////////////////////////////////////////////
		run_hip( ik ){
			//TODO NEED TO HANDLE HIP ROTATION
			let idx		= this.rig.hip.idx,
				bind 	= this.rig.bind_pose.bones[ idx ],
				pose 	= this.rig.pose_a.bones[ idx ];

			// Need to fix hip in Human Rig. It should only contain { idx: }
			// tar_bind + ( src_pose - src_bind ) * src2tar_scale
			//let p = Vec3.mul( ik.hip_dif_pos, this.hip_scale ).add( bind.world.pos ); // not Working 4 robot
			
			let p = new Vec3( bind.world.pos );
			p[1] += ik.hip_dif_pos[1] * this.hip_scale[1];

			let q = new Quat().from_mul( ik.hip_dif_rot, bind.world.rot );
				//.pmul_invert( Parent??? )

			this.rig.pose_a.set_bone( idx, q, p );	// Set Local Space
			pose.world.set( q, p );
			//pose.world.pos.copy( p );				// Set World Space for later use.
			//pose.world.rot.copy( q );
		}

		run_limb( chain, ik ){
			Pose.parent_world( this.rig.pose_a, chain.bones[0], this.pt, this.ct );

			//gRig_Animator.entity.Node.local.pos.y = 3;
			//gRig_Animator.entity.Node.isModified = true;
			//console.log( ik );

			this.target_pos
				//.from_scale( ik.fwd, chain.len * ik.len_scale )
				.from_scale( ik.fwd, (this.ik_leg_l_len || chain.len) * ik.len_scale )
				.add( this.ct.pos );

			//console.log("scale", ik.len_scale );

			//App.debug.point( this.target_pos );

			//this.target_pos.mul( [1,1,1.0] );

			// Ground collision with target
			if( this.target_pos[1] < this.grd_offset ){
				//this.target_pos[1] = this.grd_offset;

				//let s = this.grd_offset / ik.fwd[1];
				//this.target_pos
				//	.from_scale( ik.fwd, s )
				//	.add( this.ct.pos );
			}

			this.target.from_pos( this.ct.pos, this.target_pos, ik.up );
			//this.target.from_pos( this.ct.pos, this.target_pos, ik.joint_dir.pos );
			
			//console.log( this.target_pos );

			//App.debug.point( this.target_pos, 8 );
			//IKTarget.debug( App.debug, this.target );

			if( this.leg_solver == 0 )	this.target.limb( chain, this.rig.bind_pose, this.rig.pose_a, this.pt );
			else 						this.target.three_bone( chain, this.rig.bind_pose, this.rig.pose_a, this.pt );
		}

		run_foot( foot, dir_to, up_dir ){
			let bind 	= this.rig.bind_pose.bones[ foot.idx ];	// Foot's Bind Pose
			let pose 	= this.rig.pose_a.bones[ foot.idx ];	// Foot's Animated Pose
			let ppose 	= this.rig.pose_a.bones[ bind.p_idx ];	// Foot's Parent Animated Pose

			let wp 			= new Transform().from_add( ppose.world, bind.local );
			let dir_from	= Vec3.transform_quat( up_dir, wp.rot );
			
			let q = Quat
				.unit_vecs( dir_from, dir_to )		// Create Rotate based on two Direction
				.mul( wp.rot )						// Apply that rotation to our world space foot rotation
				.pmul_invert( ppose.world.rot );	// TO LOCAL SPACE!

			this.rig.pose_a.set_bone( foot.idx, q );	// Save to Pose
			pose.world									// Update World Space for Later Use.
				.copy( ppose.world )
				.add( q, bind.local.pos, bind.local.scl );

			//App.debug.point( wp.pos );
			//App.debug.line( wp.pos, Vec3.add( dir_from, wp.pos), 0 );
			//App.debug.line( wp.pos, Vec3.add( dir_to, wp.pos), 1 );
			//App.debug.point( pose.world.pos );
		}

		setup_foot( b_idx ){
			let b = this.rig.bind_pose.bones[ b_idx ],
				v = Vec3.transform_quat( Vec3.UP, b.world.rot ),
				q = new Quat().from_unit_vecs( Vec3.FORWARD, v ); // How much to get from Forward to Bone's angled forward?

			// use that change to create new up that would become forward
			// when transformed by the bind world space rotation.
			v.from_quat( q, Vec3.UP );			
			
			//v.transform_quat( b.world.rot );
			//v.add( b.world.pos );
			//App.debug.line( b.world.pos, v, 1 );

			return v;
		}
}

</script><body>
</body></html>