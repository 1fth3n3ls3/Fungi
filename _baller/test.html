<!DOCTYPE html><html><head><title></title></head><script type="module">
import App, { AppBuilder }	from "../fungi/engine/App.js";
import Arm					from "../fungi.armature/Armature.js";
import Pose 				from "../fungi.armature/Pose.js";
import Maths,{ Quat, Vec3 } from "../fungi/maths/Maths.js";
import Transform 			from "../fungi/maths/Transform.js";

import IKChain				from "../fungi.ik/IKChain.js";
import { Solver, IKTarget }	from "../fungi.ik/Solver.js";

import _NA					from "../fungi.misc/MeshLoader.js";

//#############################################################################

(function(){new AppBuilder().launch()
	.load_armature()
	.download( dl=>dl.addGrp( "shader", 
		"../fungi/shaders/VecWColor.txt",
		"../fungi.armature/shaders/ArmaturePreview.txt",
		"../fungi.armature/shaders/ArmatureSkinPhong.txt" )
		.addEntity( "Baller", "./baller", "ArmatureSkinPhong", 3, 25 )
	)
	.load_scene( true, true )
	.set_camera( -130, 15, 5.0 )
	.add_task( init )
	.render_loop( onDraw )
	.build().catch( (e)=>console.error("error",e) );
})();


//#############################################################################
function onDraw(dt, ss){
	//gBaller.bChair.Node.local.rot.rx( Maths.toRad(-30) * dt );
	//gBaller.bChair.Node.isModified = true;
	//gBaller.arm.isModified = true;

	gBaller.update(dt);

	App.ecs.sys_run();
}

let gBaller;

function init(){
	gBaller = new Baller();

	let b = gBaller.arm.get_bone("root");
	//gBaller.entity.Node.local.rot.pmul( Quat.axisAngle([0,0,1], Maths.toRad(45)));

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	return true;
}


//#############################################################################

class Baller{
	constructor( e ){
		this.vel	= new Vec3();

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		this.entity = App.ecs.entity_find( "Baller" );
		this.n		= this.entity.Node;
		this.arm 	= this.entity.Armature;
		this.bGun	= this.arm.get_bone("gun");
		this.bBall	= this.arm.get_bone("ball");
		this.bChair = this.arm.get_bone("chair");

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		//Define the Movement for each degree of rotation.
		this.ball_radius	= 0.806604;
		this.ball_len		= Math.PI * this.ball_radius * 2;	// C = Pi * 2R
		this.speed_ps 		= Maths.toRad( 90 );	// Degrees of rotation per sec.

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		this.entity.Draw.items[1].material = App.cache.getMaterial("LowPolyPhong_grayBlend");
	}

	update( dt ){
		this.kb_ctrl(dt);

		this.vel.scale( 0.85 );
		this.n.local.pos.add( this.vel );
		this.n.isModified = true;

		let len		= this.vel.length();
		let axis	= Vec3.cross( Vec3.UP, this.vel ).normalize();
		let rot		= Maths.PI_2 * (len / this.ball_len);

		let q = new Quat().setAxisAngle( axis, rot );
		this.bBall.Node.local.rot.pmul( q );
		this.bBall.Node.isModified = true;
		this.arm.isModified = true;	
	}

	kb_ctrl(dt){
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Check Direction 
		let zDir = 0, xDir = 0;

		if( App.input.arrowDown )	zDir = -1;
		if( App.input.arrowUp )		zDir = 1;
		if( App.input.arrowLeft )	xDir = 1;
		if( App.input.arrowRight )	xDir = -1;
		if( !zDir && !xDir ) return;


		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		let move	= new Vec3( Vec3.FORWARD );
		let dir		= zDir;

		if( zDir == 0 && xDir !== 0 ){				// Side Movement
			move.copy( Vec3.LEFT );
			dir = xDir;
		}else if( zDir && xDir ){					// Angle Movement
			move.rotate( Maths.toRad( 45 * xDir * zDir ), "y" ).nearZero().normalize();
		}

		this.vel.add( move.scale( 1 * dt * dir ) );
		return;

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		let rot_speed 	= -this.speed_ps * dt * dir;
		let pos_speed 	= (-rot_speed / Maths.PI_2) * this.ball_len; // AngleNorm( rot / pi2 ) * CircleLen == Distance Traveled.
		let rot_axis	= Vec3.cross( move, Vec3.UP );

		// Move Object
		this.n.local.pos.add( move.scale( pos_speed ) );
		this.n.isModified = true;

		/* Rotate Ball */
		let rot = new Quat().setAxisAngle( rot_axis, rot_speed );		
		this.bBall.Node.local.rot.pmul( rot );
		this.bBall.Node.isModified = true;
		this.arm.isModified = true;
	}
}


//#############################################################################

/*
function move(){
				let t = eSphere.com.Transform;
				let a = Maths.toRad(2);

				t._rotation.mul( new Quat().setAxisAngle(Vec3.LEFT, a) );
				t._position.z += a / (Math.PI * 2) * sphereLen;
				t._isModified = true;
			}

			let sphereLen = Math.PI * 2 * 0.5; // C = Pi * 2R
			const SPEED = Maths.toRad(5);
			const SPEED_FAST = Maths.toRad(15);
			const SPEED_STEP_INV = 1 / (Math.PI * 2) * sphereLen;

			function move_control(){
				let zDir = 0, xDir = 0;

				if(Fungi.input.arrowDown)	zDir = -1;
				if(Fungi.input.arrowUp)		zDir = 1;
				if(Fungi.input.arrowLeft)	xDir = 1;
				if(Fungi.input.arrowRight)	xDir = -1;

				if( !zDir && !xDir ) return;

				//..............................................
				let dir 	= zDir,
					pt 		= ePlayer.com.Transform,
					pFwd	= new Vec3(Vec3.FORWARD), //Api.getLocalForward(ePlayer), We don't rotate parent, so forward doesn't change
					speed 	= (!Fungi.input.spaceBar)? SPEED : SPEED_FAST;

				if(zDir == 0 && xDir != 0){
					//pFwd.rotate(Maths.toRad(90), "y").nearZero(); //Works, bot Left doesn't change
					pFwd.copy(Vec3.LEFT);
					dir = xDir;
				}else if(zDir != 0 && xDir != 0){
					pFwd.rotate(Maths.toRad(45*xDir*zDir), "y").nearZero().normalize(); //What 45 degree angle based on the two directions.
				}

				//..............................................
				// Move the parent at the rate the sphere rotates.
				pt._position.add( Vec3.scale(pFwd, speed * SPEED_STEP_INV * dir) );
				pt._isModified = true;

				//..............................................
				// Whatever the forward direction is, rotate it by 90 degrees to get an X Axis rotation based on Z Forward
				pFwd.rotate(Maths.PI_H, "y").normalize();
				let st		= eSphere.com.Transform,
					qChg	= new Quat().setAxisAngle(pFwd, speed * dir);

				st._rotation.pmul( qChg ); // newRotation = rotationChange * oldRotation, doing it backwards works better then the other way.
				st._isModified = true;
			}


			class FollowCamSystem extends System{
				constructor(target = null){
					super();
					this.target	= target;
					this.range 	= new Vec3();
				}

				update(ecs){
					if(!this.target) return;

					let ct = Fungi.camera.com.Transform,
						tt = this.target.com.Transform;

					//if camera position changed, reset distance range
					if(ct._isModified) Vec3.sub(ct._position, tt._position, this.range);

					//if target has changed, move camera along with it.
					if(tt._isModified){
						Vec3.add(tt._position, this.range, ct._position);
						ct._isModified = true;
					}
				}

				static init(t = null){ Fungi.ecs.addSystem(new FollowCamSystem( t ), 99); }
			}
 */

//#############################################################################
</script><body></body></html>