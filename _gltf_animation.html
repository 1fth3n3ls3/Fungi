<!DOCTYPE html><html><head><title></title></head><script type="module">
import App, { AppBuilder, gl, Shader, Material, Components, Entity } from "./fungi/engine/App.js";
import Vao, { Buf }	from "./fungi/core/Vao2.js";
import Maths, { Quat, Vec3 }		from "./fungi/maths/Maths.js";

import Gltf			from "./fungi.misc/GLTF.js";
import XhrPromise	from "./fungi.misc/XhrPromise.js";

import Armature			from "./fungi.armature/Armature.js";
import ArmaturePreview	from "./fungi.armature/ArmaturePreview.js";


//#############################################################################
(function(){new AppBuilder()
	.launch()
	.load_armature()
	.download( dl=>dl.addGrp( "shader", 
		"./fungi/shaders/VecWColor.txt", 
		"./fungi.armature/shaders/ArmaturePreview.txt", 
		"./fungi.armature/shaders/ArmatureSkinPhong.txt", 
	) ) 
	.load_scene( true, true, false )
	.set_camera( 0, 10, 2, 0, 0.7, 0 )
	.add( dl_files )
	//.add_task( init )
	.render_loop( onDraw )
	//.render_on_mouse( onDraw )
	.build().catch( (e)=>console.error("error",e) );
})();

window.addEventListener( "keydown", function(e){	
	switch( e.keyCode ){
		case 37: gTime -= 0.01; break; //Left
		case 39: gTime += 0.01; break; //Right
		case 38: gPause = !gPause; break; //up
		case 40: gBall.Node.local.pos.x = 2.0; gBall.Node.isModified = true; break; //Down
	}
});

async function dl_files(){
	//let dl	= await XhrPromise.get( "./RiggedSimple.gltf", "json", "./RiggedSimple0.bin", "arraybuffer" );
	let dl	= await XhrPromise.get( "./walk_anim.gltf", "json", "./walk_anim.bin", "arraybuffer" );
	
	let e		= App.$Draw( "Mesh" );
	let bones 	= Gltf.getSkin( "Armature", dl[0], dl[1] );
	

	Armature.$( e );
	gltf_armature( e, bones ); //Gltf.$armature( e, bones ); // Will Execute Armature.$() on e, then parse in bones.
	ArmaturePreview.$( e, "ArmaturePreview", 2 );

	console.log( e.Armature );
	/**/

	let anim = Gltf.getSkinAnimation( "Armature|mixamo.com|Layer0", dl[0], dl[1] ); //Armature|mixamo.com|Layer0  Animation1
	console.log( anim );
	gAnim = new AnimationBones( anim );

	/*
	let props = Gltf.getMesh( "Cylinder", dl[0], dl[1], false ); //GLTF Sample's data is interleaved, Can not test bin to vao.
	let p	= props[0];
	let vao = Vao.standard_by_data( "Mesh", p.vertices.data, 3, p.indices.data, null, null, p.joints.data, p.weights.data, p.joints.compLen );
	e.Draw.add( vao, "ArmatureSkinPhong" );
	*/
	
	//LeftLeg: 58
	//LeftUpLeg: 57
	//RightLeg: 63
	//RightUpLeg: 62

	//e.Node.local.rot.rx( Maths.toRad(90) );
	//e.Node.setScl( 0.1 );
	gModel = e;

	return true;
}

//#############################################################################
let gModel, gAnim, gPause = false;
let gTime = 0;

function onDraw( dt, ss ){
	if(!gPause) gAnim.at( gTime , gModel );
	App.ecs.sys_run();
}


//#############################################################################
function init(){
	return true;
}

function gltf_armature( e, bones, def_len=0.3 ){
	let arm = e.Armature;	

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Create Bones
	let i, b, ab, bLen = bones.length;
	for( i=0; i < bLen; i++ ){
		b	= bones[i];
		ab	= Armature.addBone( arm, b.name, 1, null, b.idx );

		if( b.rot ) ab.Node.setRot( b.rot );
		if( b.pos ) ab.Node.setPos( b.pos );
		if( b.scl ) ab.Node.setScl( b.scl );
	}

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Setting up Parent-Child
	for( i=0; i < bLen; i++ ){
		b	= bones[ i ];
		ab	= arm.bones[ b.idx ];

		// Can not have levels updated automaticly, Callstack limits get hit
		// Instead, using the Level from bones to manually set it.
		if( b.p_idx != null ) App.node.addChild( arm.bones[ b.p_idx ], ab, false );

		// Manual set node level, Must do it after addChild, else it will get overwritten.
		ab.Node.level = b.lvl; 
	}
	Armature.finalize( e );	//This updates World Transforms

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// With the WorldTransforms update, Calculate the Length of each bone.
	for( i=0; i < bLen; i++ ){
		ab	= arm.bones[ i ];
		if( ab.Node.children.length == 0 ){
			ab.Bone.length = def_len;
			continue;
		}

		b = ab.Node.children[0].Node.world;					// First Child's World Space Transform
		ab.Bone.length = ab.Node.world.pos.length( b.pos );	// Distance from Parent to Child
	}
}


/*
	1. Need to Convert Armature to T-Pose
	2. Calc T-Pose Offsets
	3. Animate

	class AnimArmature{
		constructor(){
		}
	}

	class HumanRig{
		static $( e ){
			if( e instanceof Entity && !e.HumanRig ) Entity.com_fromName( e, "HumanRig" );
		}

		constructor(){
			this.arm 	= null;
			this.hip	= null;
			this.chain	= {};

			this.arm_l	= null;
			this.arm_r	= null;
			this.leg_l	= null;
			this.leg_r	= null;
			this.spine	= null;
			this.head 	= null;
		}

		set_chain( ch_name, b_name_ary ){
			let b, ary = [];

			for( let bn of b_name_ary ){
				b = this.arm.get_bone_by_name( bn );

				ary.push({ 
					idx		: b.order,
					bind	: b.bind.clone(),
					tbind	: b.bind.cline(),
				});
			}

			this.chain[ ch_name ] = ary;
		}

		make_tpose(){
			return this;
		}
	}

	{	hip		: "",
		arm_l	: [ "","" ],
		arm_r	: [ "","" ],
		leg_r	: [ "","" ],
		leg_l	: [ "","" ],
		spine	: [ "","","","" ],
		head 	: [ "","" ],
	}




*/

// Only need to Animate Rotation mostly. Hip needs to handle Position BUT only Y most of the time.
class AnimationBones{
	constructor( a ){
		this.max_time 	= 0;
		this.time 		= null;
		this.time_i		= []; // Pre Calc the time between Frames, then invert it. 1 / (b-a)
		this.bones		= [];

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Save keyframes grouped as Bones, ties back to bone index.
		for( let i in a ){
			let b = a[ i ];

			if( !b.rot && !b.pos ) continue;

			if( !this.time && b.rot.time ) this.time = b.rot.time;

			if( b.bone_idx == 58 || b.bone_idx == 57 ){

			this.bones.push({
				idx: b.bone_idx,
				rot: b.rot.data,
			});

			}
		}

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Cache the scaler to calculate T between frames.
		for( let i=0; i < this.time.length-1; i++ ){
			this.time_i.push( 1 / ( this.time[ i+1 ] - this.time[i] ) ); //  1 / (b - a)
		}

		this.max_time = this.time[ this.time.length-1 ];

		//console.log( this.time );
		//console.log( this.max_time );

	}

	at( t, e ){
		let aBones	= e.Armature.bones,
			q		= new Quat(),
			fA		= 0, 
			fB, fT, i, b;

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// Figure out which frame we're in.
		t = t % this.max_time;	// Passing in DeltaTime, this makes sure we stay within the limit of the animation
		for( i=this.time.length-2; i > 0; i-- )
			if( this.time[ i ] < t ){ fA = i; break; }

		fB = fA + 1;
		//fT = ( t - this.time[ fA ] ) * this.time_i[ fA ];
		fT = ( t - this.time[ fA ] ) / ( this.time[ fB ] - this.time[ fA ]);

		// NOTE, Issue between Frame 4 to 5.
		// Looks like the Axis is Inverted/


		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		for( b of this.bones ){
			q_buf_lerp( b.rot, fA * 4, fB * 4, fT, q );

			if( b.idx == 57 ){
				App.debug.reset().quat( q );
				console.log( fA, fB, fT, t, this.time[ fA ], this.time[ fB ] , q.getAxisAngle() );
				q_buf_debug( b.rot, fA * 4, fB * 4 );
			}
			//q_buf_slerp( b.rot, fA * 4, fB * 4, fT, q );
			aBones[ b.idx ].Node.setRot( q );
		}

		e.Armature.isModified = true;	 
	}
}

function q_buf_lerp( ary, ai, bi, t, out ){
	let ti = 1 - t;
	out[ 0 ] = ary[ ai ] * ti + ary[ bi ] * t;
	out[ 1 ] = ary[ ai + 1 ] * ti + ary[ bi + 1 ] * t;
	out[ 2 ] = ary[ ai + 2 ] * ti + ary[ bi + 2 ] * t;
	out[ 3 ] = ary[ ai + 3 ] * ti + ary[ bi + 3 ] * t;
	return out.norm();
}

function q_buf_slerp( ary, ai, bi, t, out ){
	let ti = 1 - t;
	let qA = new Quat( ary[ ai ], ary[ ai + 1 ], ary[ ai + 2 ], ary[ ai + 3 ] );
	let qB = new Quat( ary[ bi ], ary[ bi + 1 ], ary[ bi + 2 ], ary[ bi + 3 ] );

	Quat.slerp( qA, qB, t, out )

	return out.norm();
}

function q_buf_debug( ary, ai, bi ){
	let qA = new Quat( ary[ ai ], ary[ ai + 1 ], ary[ ai + 2 ], ary[ ai + 3 ] );
	let qB = new Quat( ary[ bi ], ary[ bi + 1 ], ary[ bi + 2 ], ary[ bi + 3 ] );

	console.log( qA, qB, Quat.dot( qA, qB ) );
}

</script><body>
</body></html>